<!--
Interactive science demo.
Part of the "science-demos" project.

GitHub: https://github.com/yupic/science-demos
YouTube: https://www.youtube.com/@autism-ru
Telegram: https://t.me/autism_science
License: MIT
-->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Наследование полигенных признаков</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <script src="sd.js"></script>
  <style>
    .compact-slider input[type="range"] {
      width: 150px;
    }

    .compact-slider .slider-value {
      min-width: 40px;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Наследование полигенных признаков</h1>
  <p class="desc">Модель иллюстрирует наследование количественного признака (например, роста, IQ или количества генов).<br/>
    При полигенном наследовании математическое ожидание значения признака у ребёнка равно среднему значению признака у родителей: <code>μ_child = (mother + father) / 2</code>.<br/>
    Стандартное отклонение распределения признака у детей составляет: <code>σ<sub>child</sub> = √0.5 * σ<sub>population</sub> ≈ 0.71 * σ<sub>population</sub></code></p>
  <div class="controls">
    <label class="mut-label">Мат. ожидание:
      <input type="number" id="meanInput" min="-10000" max="10000" step="0.1" value="100" />
    </label>
    <label class="mut-label">σ:
      <input type="number" id="sdInput" min="0.1" max="10000" step="0.1" value="15" />
    </label>
    <label class="slider-label compact-slider">Сдвиг:
      <input type="range" id="shiftInput" min="-45" max="45" step="1" value="0" />
      <span id="shiftValue" class="slider-value">0</span>
    </label>
    <label class="slider-label compact-slider">Мать:
      <input type="range" id="motherInput" min="60" max="140" step="1" value="100" />
      <span id="motherValue" class="slider-value">100</span>
    </label>
    <label class="slider-label compact-slider">Отец:
      <input type="range" id="fatherInput" min="60" max="140" step="1" value="100" />
      <span id="fatherValue" class="slider-value">100</span>
    </label>
  </div>
  <div class="canvas-frame">
    <canvas id="prsCanvas"></canvas>
  </div>
</div>
<footer class="footer">
  © autism_science • MIT License •
  <a href="https://github.com/yupic/science-demos" target="_blank" rel="noopener">GitHub</a> •
  <a href="https://www.youtube.com/@autism-ru" target="_blank" rel="noopener">YouTube</a> •
  <a href="https://t.me/autism_science" target="_blank" rel="noopener">Telegram</a>
</footer>
<script>
  const canvas = document.getElementById('prsCanvas');
  const ctx = canvas.getContext('2d');
  const meanInput = document.getElementById('meanInput');
  const sdInput = document.getElementById('sdInput');
  const shiftInput = document.getElementById('shiftInput');
  const motherInput = document.getElementById('motherInput');
  const fatherInput = document.getElementById('fatherInput');
  const shiftValue = document.getElementById('shiftValue');
  const motherValue = document.getElementById('motherValue');
  const fatherValue = document.getElementById('fatherValue');

  const colors = {
    population: 'rgba(44, 123, 229, 0.75)',
    child: 'rgba(227, 52, 47, 0.75)',
    mother: 'rgba(147, 51, 234, 0.9)',
    father: 'rgba(16, 185, 129, 0.9)'
  };

  function normalPdf(x, mean, sigma) {
    const coef = 1 / (sigma * Math.sqrt(2 * Math.PI));
    const z = (x - mean) / sigma;
    return coef * Math.exp(-0.5 * z * z);
  }

  function normalCdf(x, mean, sigma) {
    const z = (x - mean) / (sigma * Math.sqrt(2));
    const sign = z < 0 ? -1 : 1;
    const absZ = Math.abs(z);
    const t = 1 / (1 + 0.3275911 * absZ);
    const coefficients = [0.254829592, -0.284496736, 1.421413741, -1.453152027, 1.061405429];
    const erf =
      1 -
      (((((coefficients[4] * t + coefficients[3]) * t + coefficients[2]) * t + coefficients[1]) * t + coefficients[0]) *
        t *
        Math.exp(-absZ * absZ));
    const erfValue = sign * erf;
    return 0.5 * (1 + erfValue);
  }

  function formatFromStep(value, step) {
    if (!Number.isFinite(step) || step <= 0) return value.toFixed(0);
    const decimals = step >= 1 ? 0 : Math.max(0, Math.min(6, Math.ceil(-Math.log10(step))));
    return Number(value).toFixed(decimals);
  }

  function getPopulationMean() {
    const val = Number(meanInput.value);
    if (!Number.isFinite(val)) {
      meanInput.value = 100;
      return 100;
    }
    const clamped = Math.min(Math.max(val, -10000), 10000);
    if (clamped !== val) {
      meanInput.value = clamped;
    }
    return clamped;
  }

  function getPopulationSigma() {
    const val = Number(sdInput.value);
    if (!Number.isFinite(val) || val <= 0) {
      sdInput.value = 15;
      return 15;
    }
    const clamped = Math.min(Math.max(val, 0.1), 10000);
    if (clamped !== val) {
      sdInput.value = clamped;
    }
    return clamped;
  }

  let lastBaseMean = getPopulationMean();
  let lastBaseSigma = getPopulationSigma();

  function computeSliderStep(sigma) {
    const range = 6 * sigma;
    if (!Number.isFinite(range) || range <= 0) return 1;
    const candidates = [];
    for (let exp = -10; exp <= 10; exp++) {
      const step = 10 ** exp;
      const divisions = range / step;
      if (divisions >= 10 && divisions <= 200) {
        candidates.push({ step, divisions });
      }
    }

    if (candidates.length) {
      return candidates.reduce(
        (best, current) => {
          const score = Math.abs(current.divisions - 100);
          if (score < best.score) return { step: current.step, score };
          return best;
        },
        { step: candidates[0].step, score: Math.abs(candidates[0].divisions - 100) }
      ).step;
    }

    const approx = range / 100;
    const exp = Math.round(Math.log10(Math.max(approx, 1e-8)));
    return 10 ** exp;
  }

  function updateSliderBounds(mean, sigma, { forceParentValue = false } = {}) {
    const min = mean - 3 * sigma;
    const max = mean + 3 * sigma;
    const step = computeSliderStep(sigma);

    [motherInput, fatherInput].forEach((input) => {
      input.min = min;
      input.max = max;
      input.step = step;
      if (forceParentValue) input.value = mean;
      const current = Number(input.value);
      let value = current;
      if (!Number.isFinite(value)) value = mean;
      value = Math.min(Math.max(value, min), max);
      input.value = value;
    });

    const shiftMin = -3 * sigma;
    const shiftMax = 3 * sigma;
    shiftInput.min = shiftMin;
    shiftInput.max = shiftMax;
    shiftInput.step = step;
    let shiftVal = Number(shiftInput.value);
    if (forceParentValue || !Number.isFinite(shiftVal)) shiftVal = 0;
    shiftVal = Math.min(Math.max(shiftVal, shiftMin), shiftMax);
    shiftInput.value = shiftVal;

    return { step, min, max };
  }

  function updateLabels(step) {
    const sliderStep = step ?? (Number(motherInput.step) || 1);
    shiftValue.textContent = formatFromStep(shiftInput.value, sliderStep);
    motherValue.textContent = formatFromStep(motherInput.value, sliderStep);
    fatherValue.textContent = formatFromStep(fatherInput.value, sliderStep);
  }

  function draw() {
    const populationMean = getPopulationMean();
    const populationSigma = getPopulationSigma();
    const baseChanged = populationMean !== lastBaseMean || populationSigma !== lastBaseSigma;
    const { step: sliderStep } = updateSliderBounds(populationMean, populationSigma, { forceParentValue: baseChanged });
    lastBaseMean = populationMean;
    lastBaseSigma = populationSigma;

    const motherMean = Number(motherInput.value);
    const fatherMean = Number(fatherInput.value);
    const shift = Number(shiftInput.value) || 0;
    const childMean = (motherMean + fatherMean) / 2 + shift;
    const childSigma = Math.sqrt(0.5) * populationSigma;
    const xMin = populationMean - 4 * populationSigma;
    const xMax = populationMean + 4 * populationSigma;

    updateLabels(sliderStep);

    const dpr = window.devicePixelRatio || 1;
    const displayWidth = canvas.clientWidth || canvas.parentElement.clientWidth || 600;
    const targetHeight = Math.max(360, Math.min(window.innerHeight * 0.7, 560));
    canvas.style.height = `${targetHeight}px`;
    canvas.width = Math.floor(displayWidth * dpr);
    canvas.height = Math.floor(targetHeight * dpr);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    const marginLeft = 64;
    const marginRight = 16;
    const marginBottom = 40;
    const marginTop = 30;
    const dividerGap = 28 + marginTop;
    const innerWidth = width - marginLeft - marginRight;
    const innerHeightTotal = height - marginTop - marginBottom;
    const panelHeight = (innerHeightTotal - dividerGap) / 2;
    const childPanel = { y: marginTop, height: panelHeight };
    const populationPanel = { y: marginTop + panelHeight + dividerGap, height: panelHeight };

    drawTitles({ childPanel, populationPanel, marginLeft, childTitle: 'Распределение признака у ребёнка', populationTitle: 'Распределение признака в популяции' });

    const sampling = 400;
    const step = (xMax - xMin) / (sampling - 1);
    const populationPoints = [];
    const childPoints = [];
    for (let i = 0; i < sampling; i++) {
      const x = xMin + step * i;
      populationPoints.push({ x, y: normalPdf(x, populationMean, populationSigma) });
      childPoints.push({ x, y: normalPdf(x, childMean, childSigma) });
    }

    const maxChildY = Math.max(...childPoints.map((p) => p.y), 1e-6);
    const maxPopulationY = Math.max(...populationPoints.map((p) => p.y), 1e-6);

    const { ticks: childYTicks, maxValue: childYMax } = generateYTicks(maxChildY);
    const { ticks: populationYTicks, maxValue: populationYMax } = generateYTicks(maxPopulationY);
    const scaleX = innerWidth / (xMax - xMin);

    drawPopulationBands({
      marginLeft,
      innerWidth,
      panel: populationPanel,
      mean: populationMean,
      sigma: populationSigma,
      xMin,
      xMax
    });

    drawPopulationBands({
      marginLeft,
      innerWidth,
      panel: childPanel,
      mean: childMean,
      sigma: childSigma,
      xMin,
      xMax
    });

    drawBandProbabilities({
      mean: populationMean,
      sigma: populationSigma,
      panel: populationPanel,
      marginLeft,
      innerWidth,
      xMin,
      xMax
    });

    drawBandProbabilities({
      mean: childMean,
      sigma: childSigma,
      panel: childPanel,
      marginLeft,
      innerWidth,
      xMin,
      xMax
    });

    drawCurve({
      points: childPoints,
      color: colors.child,
      width: 2,
      panel: childPanel,
      scaleX,
      xMin,
      yMax: childYMax,
      marginLeft
    });

    drawCurve({
      points: populationPoints,
      color: colors.population,
      width: 4,
      panel: populationPanel,
      scaleX,
      xMin,
      yMax: populationYMax,
      marginLeft
    });

    drawSigmaLines({
      mean: childMean,
      sigma: childSigma,
      color: colors.child,
      panel: childPanel,
      xMin,
      xMax,
      marginLeft,
      innerWidth
    });

    const childProbLabelY = drawChildProbabilities({
      childMean,
      childSigma,
      panel: childPanel,
      marginLeft,
      innerWidth,
      xMin,
      xMax,
      populationMean,
      populationSigma
    });

    drawSharedSigmaConnectors({
      mean: populationMean,
      sigma: populationSigma,
      xMin,
      xMax,
      marginLeft,
      innerWidth,
      childPanel,
      populationPanel,
      childLabelY: childProbLabelY
    });

    drawSigmaLines({
      mean: populationMean,
      sigma: populationSigma,
      color: colors.population,
      panel: populationPanel,
      xMin,
      xMax,
      marginLeft,
      innerWidth
    });

    drawParentMarkers(
      [
        { value: motherMean, label: 'Мать', color: colors.mother },
        { value: childMean, label: 'Ребёнок', color: colors.child },
        { value: fatherMean, label: 'Отец', color: colors.father }
      ],
      { xMin, xMax, marginLeft, innerWidth, panel: populationPanel, step: sliderStep }
    );

    drawAxes({
      xMin,
      xMax,
      marginLeft,
      innerWidth,
      panel: childPanel,
      marginRight,
      yTicks: childYTicks,
      yMax: childYMax,
      showXAxis: false,
      yLabel: 'Плотность'
    });

    drawAxes({
      xMin,
      xMax,
      marginLeft,
      innerWidth,
      panel: populationPanel,
      marginRight,
      yTicks: populationYTicks,
      yMax: populationYMax,
      showXAxis: true,
      yLabel: 'Плотность'
    });

    const dividerY = marginTop + panelHeight + dividerGap / 2;
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(marginLeft, dividerY);
    ctx.lineTo(width - marginRight, dividerY);
    ctx.stroke();

    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  function drawSigmaLines({
    mean,
    sigma,
    color,
    panel,
    xMin,
    xMax,
    marginLeft,
    innerWidth
  }) {
    const xRange = xMax - xMin;
    const lineTop = panel.y + 36;
    if (!Number.isFinite(mean) || !Number.isFinite(sigma)) return;
    const lineColor = color.replace('0.75', '0.95');
    const levels = [1, 2, 3];
    ctx.lineWidth = 1;
    levels.forEach((k) => {
      const positions = [mean - sigma * k, mean + sigma * k];
      positions.forEach((actualPos) => {
        const x = marginLeft + ((actualPos - xMin) / xRange) * innerWidth;
        if (x < marginLeft || x > marginLeft + innerWidth) return;
        const sign = actualPos < mean ? '-' : '+';
        ctx.strokeStyle = lineColor;
        //ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(x, lineTop);
        ctx.lineTo(x, panel.y + panel.height);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = lineColor;
        ctx.font = '15px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(`${sign}${k}σ`, x, panel.y + 2);
        ctx.fillText(actualPos.toFixed(1), x, panel.y + 20);
      });
    });
    const meanX = marginLeft + ((mean - xMin) / xRange) * innerWidth;
    if (meanX >= marginLeft && meanX <= marginLeft + innerWidth) {
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1;
      //ctx.setLineDash([2, 6]);
      ctx.beginPath();
      ctx.moveTo(meanX, panel.y);
      ctx.lineTo(meanX, panel.y + panel.height);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  shiftInput.addEventListener('input', draw);
  motherInput.addEventListener('input', draw);
  fatherInput.addEventListener('input', draw);
  meanInput.addEventListener('input', draw);
  sdInput.addEventListener('input', draw);

  draw();
  window.addEventListener('resize', draw);

  function drawTitles({ childPanel, populationPanel, marginLeft, childTitle, populationTitle }) {
    ctx.save();
    ctx.fillStyle = '#333';
    ctx.font = '16px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';
    if (childPanel) {
      ctx.fillText(childTitle, marginLeft, childPanel.y - 4);
    }
    if (populationPanel) {
      ctx.fillText(populationTitle, marginLeft, populationPanel.y - 4);
    }
    ctx.restore();
  }

  function drawPopulationBands({ marginLeft, innerWidth, panel, mean, sigma, xMin, xMax }) {
    const bands = [
      { from: -Infinity, to: mean - 3 * sigma, color: '#ffe3e6' },
      { from: mean + 3 * sigma, to: Infinity, color: '#ffe3e6' },
      { from: mean - 3 * sigma, to: mean - 2 * sigma, color: '#ffeacc' },
      { from: mean + 2 * sigma, to: mean + 3 * sigma, color: '#ffeacc' },
      { from: mean - 2 * sigma, to: mean - 1 * sigma, color: '#eaf6e5' },
      { from: mean + 1 * sigma, to: mean + 2 * sigma, color: '#eaf6e5' },
      { from: mean - 1 * sigma, to: mean + 1 * sigma, color: '#e3ecff' }
    ];

    bands.forEach(({ from, to, color }) => {
      const clampedFrom = Math.max(from, xMin);
      const clampedTo = Math.min(to, xMax);
      if (clampedTo <= clampedFrom) return;
      const xStart = marginLeft + ((clampedFrom - xMin) / (xMax - xMin)) * innerWidth;
      const width = ((clampedTo - clampedFrom) / (xMax - xMin)) * innerWidth;
      ctx.fillStyle = color;
      ctx.fillRect(xStart, panel.y, width, panel.height);
    });
  }

  function drawCurve({ points, color, width, panel, scaleX, xMin, yMax, marginLeft }) {
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.beginPath();
    points.forEach((pt, idx) => {
      const x = marginLeft + (pt.x - xMin) * scaleX;
      const y = panel.y + panel.height - (pt.y / yMax) * panel.height;
      if (idx === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }

  function drawParentMarkers(parents, { xMin, xMax, marginLeft, innerWidth, panel, step }) {
    const xRange = xMax - xMin;
    const markers = parents
      .map(({ value, label, color }) => {
        const x = marginLeft + ((value - xMin) / xRange) * innerWidth;
        return { value, label, color, x };
      })
      .filter(({ value, x }) => Number.isFinite(value) && x >= marginLeft && x <= marginLeft + innerWidth);

    markers.forEach(({ x, color }) => {
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.moveTo(x, panel.y);
      ctx.lineTo(x, panel.y + panel.height);
      ctx.stroke();
      ctx.setLineDash([]);
    });

    if (!markers.length) return;

    const labelY = Math.max(16, panel.y - 4);
    const gap = 8;
    const font = '15px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.font = font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';

    const items = markers.map((marker) => {
      const textValue = formatFromStep(marker.value, step || 1);
      const text = `${marker.label}: ${textValue}`;
      const metrics = ctx.measureText(text);
      const width = metrics.width;
      const height = 16;
      return { ...marker, text, width, height };
    });

    const labelPriority = { Мать: 0, Ребёнок: 1, Отец: 2 };
    const overlaps = (a, b) =>
      a.x + a.width / 2 + gap / 2 >= b.x - b.width / 2 - gap / 2 &&
      b.x + b.width / 2 + gap / 2 >= a.x - a.width / 2 - gap / 2;

    const sorted = items
      .slice()
      .sort((a, b) => {
        if (a.value === b.value) {
          const pa = labelPriority[a.label] ?? 99;
          const pb = labelPriority[b.label] ?? 99;
          return pa - pb;
        }
        return a.value - b.value;
      });

    const groups = [];
    sorted.forEach((item) => {
      const lastGroup = groups[groups.length - 1];
      if (lastGroup && overlaps(lastGroup[lastGroup.length - 1], item)) {
        lastGroup.push(item);
      } else {
        groups.push([item]);
      }
    });

    const positions = groups.flatMap((group) => {
      const center = group.reduce((sum, item) => sum + item.x, 0) / group.length;
      const totalWidth = group.reduce((sum, item) => sum + item.width, 0) + gap * (group.length - 1);
      let cursor = center - totalWidth / 2 + group[0].width / 2;
      return group.map((item, idx) => {
        const drawX = cursor;
        //cursor += item.width + gap;
        if (idx < group.length - 1) {
          cursor += item.width / 2 + gap + group[idx + 1].width / 2;
        }
        return { ...item, drawX, drawY: labelY };
      });
    });

    positions.forEach((item) => {
      ctx.fillStyle = item.color;
      ctx.fillText(item.text, item.drawX, item.drawY);
    });
  }

  function drawChildProbabilities({
    childMean,
    childSigma,
    panel,
    marginLeft,
    innerWidth,
    xMin,
    xMax,
    populationMean,
    populationSigma
  }) {
    const thresholds = [-3, -2, -1, 0, 1, 2, 3].map((k) => populationMean + k * populationSigma);

    const clamp = (value) => Math.min(Math.max(value, xMin), xMax);
    const xRange = xMax - xMin;
    const toCanvasX = (val) => marginLeft + ((val - xMin) / xRange) * innerWidth;

    const labels = thresholds.map((value) => {
      const cdf = normalCdf(value, childMean, childSigma);
      return {
        x: clamp(value),
        below: cdf,
        above: 1 - cdf
      };
    });

    ctx.fillStyle = '#444';
    ctx.font = '13px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    const y = panel.y + panel.height + 6;
    labels.forEach(({ x, below, above }) => {
      ctx.fillText(`${(below * 100).toFixed(1)}% / ${(above * 100).toFixed(1)}%`, toCanvasX(x), y);
    });

    return y;
  }

  function drawSharedSigmaConnectors({
    mean,
    sigma,
    xMin,
    xMax,
    marginLeft,
    innerWidth,
    childPanel,
    populationPanel,
    childLabelY
  }) {
    const xRange = xMax - xMin;
    const positions = [-3, -2, -1, 0, 1, 2, 3].map((k) => mean + k * sigma);
    const childGapStart = childLabelY - 10;
    //const childGapEnd = childLabelY + 16;
    //const populationGapStart = populationPanel.y;
    //const populationGapEnd = populationPanel.y + 32;
    const bottomY = populationPanel.y + populationPanel.height;
    const topY = childPanel.y;

    ctx.save();
    ctx.strokeStyle = 'rgba(44, 123, 229, 0.4)'; //'rgba(0, 0, 0, 0.2)';//'#666';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 6]);

    positions.forEach((value) => {
      if (!Number.isFinite(value)) return;
      const x = marginLeft + ((value - xMin) / xRange) * innerWidth;
      if (x < marginLeft || x > marginLeft + innerWidth) return;

      const segments = [
        { start: topY, end: childGapStart },
        //{ start: childGapEnd, end: populationGapStart - 6 },
        //{ start: populationGapEnd, end: bottomY }
      ];

      segments.forEach(({ start, end }) => {
        if (!Number.isFinite(start) || !Number.isFinite(end)) return;
        const segStart = Math.max(start, topY);
        const segEnd = Math.min(end, bottomY);
        if (segEnd <= segStart) return;
        ctx.beginPath();
        ctx.moveTo(x, segStart);
        ctx.lineTo(x, segEnd);
        ctx.stroke();
      });
    });

    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawAxes({
    xMin,
    xMax,
    marginLeft,
    innerWidth,
    panel,
    marginRight,
    yTicks,
    yMax,
    showXAxis,
    yLabel
  }) {
    const y0 = panel.y + panel.height;
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(marginLeft, y0);
    ctx.lineTo(marginLeft, panel.y);
    ctx.stroke();

    ctx.fillStyle = '#444';
    ctx.font = '12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    yTicks.forEach((tick) => {
      const y = panel.y + panel.height - (tick / yMax) * panel.height;
      ctx.beginPath();
      ctx.moveTo(marginLeft - 4, y);
      ctx.lineTo(marginLeft, y);
      ctx.stroke();
      ctx.fillText(tick.toFixed(4), marginLeft - 6, y);
    });

    ctx.save();
    ctx.translate(10, panel.y + panel.height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    if (showXAxis) {
      const xRange = xMax - xMin || 1;
      const xAxisY = panel.y + panel.height;

      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(marginLeft, xAxisY);
      ctx.lineTo(marginLeft + innerWidth, xAxisY);
      ctx.stroke();

      ctx.fillStyle = '#444';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      const labelValues = generateXTicks({ min: xMin, max: xMax }, innerWidth);
      const stepForFormat = labelValues.length >= 2 ? Math.abs(labelValues[1] - labelValues[0]) : 1;
      const decimals = stepForFormat >= 1 ? 0 : Math.max(0, Math.min(6, Math.ceil(-Math.log10(stepForFormat))));
      const formatTick = (value) => {
        if (decimals === 0) return Math.round(value).toString();
        return Number(value.toFixed(decimals)).toString();
      };

      for (const value of labelValues) {
        const x = marginLeft + ((value - xMin) / xRange) * innerWidth;
        const label = formatTick(value);
        ctx.beginPath();
        ctx.moveTo(x, xAxisY);
        ctx.lineTo(x, xAxisY + 4);
        ctx.stroke();
        ctx.fillText(label, x, xAxisY + 6);
      }
    }
  }

  function drawBandProbabilities({ mean, sigma, panel, marginLeft, innerWidth, xMin, xMax }) {
    const boundaries = [
      -Infinity,
      mean - 3 * sigma,
      mean - 2 * sigma,
      mean - 1 * sigma,
      mean,
      mean + 1 * sigma,
      mean + 2 * sigma,
      mean + 3 * sigma,
      Infinity
    ];

    const xRange = xMax - xMin;
    const centerY = panel.y + panel.height / 2;
    ctx.fillStyle = 'rgba(60, 60, 60, 0.3)';
    ctx.font = '24px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let i = 0; i < boundaries.length - 1; i++) {
      const left = boundaries[i];
      const right = boundaries[i + 1];
      const leftProb = left === -Infinity ? 0 : normalCdf(left, mean, sigma);
      const rightProb = right === Infinity ? 1 : normalCdf(right, mean, sigma);
      const prob = rightProb - leftProb;

      const clampedLeft = Math.max(left, xMin);
      const clampedRight = Math.min(right, xMax);
      if (clampedRight <= clampedLeft) continue;
      const centerXValue = clampedLeft + (clampedRight - clampedLeft) / 2;
      const centerX = marginLeft + ((centerXValue - xMin) / xRange) * innerWidth;
      ctx.fillText(`${(prob * 100).toFixed(2)}%`, centerX, centerY);
    }
  }
</script>
</body>
</html>
