<!--
Interactive science demo.
Part of the "science-demos" project.

GitHub: https://github.com/yupic/science-demos
YouTube: https://www.youtube.com/@autism-ru
Telegram: https://t.me/autism_science
License: MIT
-->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Наследование PRS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <script src="sd.js"></script>
</head>
<body>
<div class="container">
  <h1>Как PRS ребёнка зависит от родителей</h1>
  <p class="desc">Нормальные распределения PRS для популяции и гипотетического ребёнка. Изменяйте PRS родителей, чтобы увидеть смещение среднего ребёнка.</p>
  <div class="controls">
    <label class="slider-label">Мать:
      <input type="range" id="motherInput" min="60" max="140" step="1" value="100" />
      <span id="motherValue" class="slider-value">100</span>
    </label>
    <label class="slider-label">Отец:
      <input type="range" id="fatherInput" min="60" max="140" step="1" value="100" />
      <span id="fatherValue" class="slider-value">100</span>
    </label>
  </div>
  <div class="canvas-frame">
    <canvas id="prsCanvas"></canvas>
  </div>
</div>
<footer class="footer">
  © autism_science • MIT License •
  <a href="https://github.com/yupic/science-demos" target="_blank" rel="noopener">GitHub</a> •
  <a href="https://www.youtube.com/@autism-ru" target="_blank" rel="noopener">YouTube</a> •
  <a href="https://t.me/autism_science" target="_blank" rel="noopener">Telegram</a>
</footer>
<script>
  const canvas = document.getElementById('prsCanvas');
  const ctx = canvas.getContext('2d');
  const motherInput = document.getElementById('motherInput');
  const fatherInput = document.getElementById('fatherInput');
  const motherValue = document.getElementById('motherValue');
  const fatherValue = document.getElementById('fatherValue');

  const populationMean = 100;
  const populationSigma = 15;
  const childSigma = Math.sqrt(0.5) * populationSigma;
  const xMin = 40;
  const xMax = 160;

  const colors = {
    population: 'rgba(44, 123, 229, 0.75)',
    child: 'rgba(227, 52, 47, 0.75)',
    mother: 'rgba(147, 51, 234, 0.9)',
    father: 'rgba(16, 185, 129, 0.9)'
  };

  function normalPdf(x, mean, sigma) {
    const coef = 1 / (sigma * Math.sqrt(2 * Math.PI));
    const z = (x - mean) / sigma;
    return coef * Math.exp(-0.5 * z * z);
  }

  function normalCdf(x, mean, sigma) {
    const z = (x - mean) / (sigma * Math.sqrt(2));
    const sign = z < 0 ? -1 : 1;
    const absZ = Math.abs(z);
    const t = 1 / (1 + 0.3275911 * absZ);
    const coefficients = [0.254829592, -0.284496736, 1.421413741, -1.453152027, 1.061405429];
    const erf =
      1 -
      (((((coefficients[4] * t + coefficients[3]) * t + coefficients[2]) * t + coefficients[1]) * t + coefficients[0]) *
        t *
        Math.exp(-absZ * absZ));
    const erfValue = sign * erf;
    return 0.5 * (1 + erfValue);
  }

  function updateLabels() {
    motherValue.textContent = motherInput.value;
    fatherValue.textContent = fatherInput.value;
  }

  function draw() {
    const motherMean = Number(motherInput.value);
    const fatherMean = Number(fatherInput.value);
    const childMean = (motherMean + fatherMean) / 2;

    updateLabels();

    const dpr = window.devicePixelRatio || 1;
    const displayWidth = canvas.clientWidth || canvas.parentElement.clientWidth || 600;
    const targetHeight = Math.max(360, Math.min(window.innerHeight * 0.7, 560));
    canvas.style.height = `${targetHeight}px`;
    canvas.width = Math.floor(displayWidth * dpr);
    canvas.height = Math.floor(targetHeight * dpr);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    const marginLeft = 64;
    const marginRight = 16;
    const marginBottom = 40;
    const marginTop = 16;
    const dividerGap = 28 + marginTop;
    const innerWidth = width - marginLeft - marginRight;
    const innerHeightTotal = height - marginTop - marginBottom;
    const panelHeight = (innerHeightTotal - dividerGap) / 2;
    const childPanel = { y: marginTop, height: panelHeight };
    const populationPanel = { y: marginTop + panelHeight + dividerGap, height: panelHeight };

    const sampling = 400;
    const step = (xMax - xMin) / (sampling - 1);
    const populationPoints = [];
    const childPoints = [];
    for (let i = 0; i < sampling; i++) {
      const x = xMin + step * i;
      populationPoints.push({ x, y: normalPdf(x, populationMean, populationSigma) });
      childPoints.push({ x, y: normalPdf(x, childMean, childSigma) });
    }

    const maxChildY = Math.max(...childPoints.map((p) => p.y), 0.01);
    const maxPopulationY = Math.max(...populationPoints.map((p) => p.y), 0.01);

    const { ticks: childYTicks, maxValue: childYMax } = generateYTicks(maxChildY);
    const { ticks: populationYTicks, maxValue: populationYMax } = generateYTicks(maxPopulationY);
    const scaleX = innerWidth / (xMax - xMin);

    drawPopulationBands({
      marginLeft,
      innerWidth,
      panel: populationPanel,
      mean: populationMean,
      sigma: populationSigma
    });

    drawPopulationBands({
      marginLeft,
      innerWidth,
      panel: childPanel,
      mean: childMean,
      sigma: childSigma
    });

    drawCurve({
      points: childPoints,
      color: colors.child,
      width: 2,
      panel: childPanel,
      scaleX,
      xMin,
      yMax: childYMax,
      marginLeft
    });

    drawCurve({
      points: populationPoints,
      color: colors.population,
      width: 4,
      panel: populationPanel,
      scaleX,
      xMin,
      yMax: populationYMax,
      marginLeft
    });

    drawSigmaLines({
      mean: childMean,
      sigma: childSigma,
      color: colors.child,
      panel: childPanel,
      xMin,
      xMax,
      marginLeft,
      innerWidth
    });

    drawChildProbabilities({
      childMean,
      childSigma,
      panel: childPanel,
      marginLeft,
      innerWidth,
      xMin,
      xMax,
      populationMean,
      populationSigma
    });

    drawSigmaLines({
      mean: populationMean,
      sigma: populationSigma,
      color: colors.population,
      panel: populationPanel,
      xMin,
      xMax,
      marginLeft,
      innerWidth
    });

    drawParentMarkers(
      [
        { value: motherMean, label: 'Мать', color: colors.mother },
        { value: fatherMean, label: 'Отец', color: colors.father }
      ],
      { xMin, xMax, marginLeft, innerWidth, panel: populationPanel }
    );

    drawAxes({
      xMin,
      xMax,
      marginLeft,
      innerWidth,
      panel: childPanel,
      marginRight,
      yTicks: childYTicks,
      yMax: childYMax,
      showXAxis: false,
      yLabel: 'Плотность'
    });

    drawAxes({
      xMin,
      xMax,
      marginLeft,
      innerWidth,
      panel: populationPanel,
      marginRight,
      yTicks: populationYTicks,
      yMax: populationYMax,
      showXAxis: true,
      yLabel: 'Плотность'
    });

    const dividerY = marginTop + panelHeight + dividerGap / 2;
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(marginLeft, dividerY);
    ctx.lineTo(width - marginRight, dividerY);
    ctx.stroke();

    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  function drawSigmaLines({
    mean,
    sigma,
    color,
    panel,
    xMin,
    xMax,
    marginLeft,
    innerWidth
  }) {
    const xRange = xMax - xMin;
    const lineTop = panel.y + 32;
    if (!Number.isFinite(mean) || !Number.isFinite(sigma)) return;
    const lineColor = color.replace('0.75', '0.95');
    const levels = [1, 2, 3];
    ctx.lineWidth = 1;
    levels.forEach((k) => {
      const positions = [mean - sigma * k, mean + sigma * k];
      positions.forEach((actualPos) => {
        const x = marginLeft + ((actualPos - xMin) / xRange) * innerWidth;
        if (x < marginLeft || x > marginLeft + innerWidth) return;
        const sign = actualPos < mean ? '-' : '+';
        ctx.strokeStyle = lineColor;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(x, lineTop);
        ctx.lineTo(x, panel.y + panel.height);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = lineColor;
        ctx.font = '15px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(`${sign}${k}σ`, x, panel.y + 2);
        ctx.fillText(actualPos.toFixed(1), x, panel.y + 20);
      });
    });
    const meanX = marginLeft + ((mean - xMin) / xRange) * innerWidth;
    if (meanX >= marginLeft && meanX <= marginLeft + innerWidth) {
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1.5;
      ctx.setLineDash([2, 6]);
      ctx.beginPath();
      ctx.moveTo(meanX, panel.y);
      ctx.lineTo(meanX, panel.y + panel.height);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  motherInput.addEventListener('input', draw);
  fatherInput.addEventListener('input', draw);

  draw();

  function drawPopulationBands({ marginLeft, innerWidth, panel, mean, sigma }) {
    const bands = [
      { from: -Infinity, to: mean - 3 * sigma, color: '#ffe3e6' },
      { from: mean + 3 * sigma, to: Infinity, color: '#ffe3e6' },
      { from: mean - 3 * sigma, to: mean - 2 * sigma, color: '#ffeacc' },
      { from: mean + 2 * sigma, to: mean + 3 * sigma, color: '#ffeacc' },
      { from: mean - 2 * sigma, to: mean - 1 * sigma, color: '#eaf6e5' },
      { from: mean + 1 * sigma, to: mean + 2 * sigma, color: '#eaf6e5' },
      { from: mean - 1 * sigma, to: mean + 1 * sigma, color: '#e3ecff' }
    ];

    bands.forEach(({ from, to, color }) => {
      const clampedFrom = Math.max(from, xMin);
      const clampedTo = Math.min(to, xMax);
      if (clampedTo <= clampedFrom) return;
      const xStart = marginLeft + ((clampedFrom - xMin) / (xMax - xMin)) * innerWidth;
      const width = ((clampedTo - clampedFrom) / (xMax - xMin)) * innerWidth;
      ctx.fillStyle = color;
      ctx.fillRect(xStart, panel.y, width, panel.height);
    });
  }

  function drawCurve({ points, color, width, panel, scaleX, xMin, yMax, marginLeft }) {
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.beginPath();
    points.forEach((pt, idx) => {
      const x = marginLeft + (pt.x - xMin) * scaleX;
      const y = panel.y + panel.height - (pt.y / yMax) * panel.height;
      if (idx === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }

  function drawParentMarkers(parents, { xMin, xMax, marginLeft, innerWidth, panel }) {
    const xRange = xMax - xMin;
    const labelY = Math.max(10, panel.y - 6);
    parents.forEach(({ value, label, color }) => {
      if (!Number.isFinite(value)) return;
      const x = marginLeft + ((value - xMin) / xRange) * innerWidth;
      if (x < marginLeft || x > marginLeft + innerWidth) return;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.moveTo(x, panel.y);
      ctx.lineTo(x, panel.y + panel.height);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = color;
      ctx.font = '15px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(`${label}: ${value.toFixed(0)}`, x, labelY);
    });
  }

  function drawChildProbabilities({
    childMean,
    childSigma,
    panel,
    marginLeft,
    innerWidth,
    xMin,
    xMax,
    populationMean,
    populationSigma
  }) {
    const a = populationMean - 3 * populationSigma;
    const b = populationMean - 2 * populationSigma;
    const probA = normalCdf(a, childMean, childSigma);
    const probB = normalCdf(b, childMean, childSigma);

    const clamp = (value) => Math.min(Math.max(value, xMin), xMax);
    const xRange = xMax - xMin;
    const toCanvasX = (val) => marginLeft + ((val - xMin) / xRange) * innerWidth;

    const labels = [
      { x: clamp(a), value: probA },
      { x: clamp(b), value: probB }
    ];

    ctx.fillStyle = '#444';
    ctx.font = '13px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    const y = panel.y + panel.height + 6;
    labels.forEach(({ x, value }) => {
      ctx.fillText(`${(value * 100).toFixed(2)}%`, toCanvasX(x), y);
    });
  }

  function drawAxes({
    xMin,
    xMax,
    marginLeft,
    innerWidth,
    panel,
    marginRight,
    yTicks,
    yMax,
    showXAxis,
    yLabel
  }) {
    const y0 = panel.y + panel.height;
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(marginLeft, y0);
    ctx.lineTo(marginLeft, panel.y);
    ctx.stroke();

    ctx.fillStyle = '#444';
    ctx.font = '12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    yTicks.forEach((tick) => {
      const y = panel.y + panel.height - (tick / yMax) * panel.height;
      ctx.beginPath();
      ctx.moveTo(marginLeft - 4, y);
      ctx.lineTo(marginLeft, y);
      ctx.stroke();
      ctx.fillText(`${(tick * 100).toFixed(2)}%`, marginLeft - 6, y);
    });

    ctx.save();
    ctx.translate(20, panel.y + panel.height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    if (showXAxis) {
      const xMinEdge = xMin - 0.5;
      const xMaxEdge = xMax + 0.5;
      const xRange = xMaxEdge - xMinEdge || 1;
      const xAxisY = panel.y + panel.height;

      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(marginLeft, xAxisY);
      ctx.lineTo(marginLeft + innerWidth, xAxisY);
      ctx.stroke();

      ctx.fillStyle = '#444';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      const labelValues = generateXTicks({ min: xMin, max: xMax }, innerWidth);
      const stepForFormat = labelValues.length >= 2 ? Math.abs(labelValues[1] - labelValues[0]) : 1;
      const decimals = stepForFormat >= 1 ? 0 : Math.max(0, Math.min(6, Math.ceil(-Math.log10(stepForFormat))));
      const formatTick = (value) => {
        if (decimals === 0) return Math.round(value).toString();
        return Number(value.toFixed(decimals)).toString();
      };

      for (const value of labelValues) {
        const x = marginLeft + ((value - xMinEdge) / xRange) * innerWidth;
        const label = formatTick(value);
        ctx.beginPath();
        ctx.moveTo(x, xAxisY);
        ctx.lineTo(x, xAxisY + 4);
        ctx.stroke();
        ctx.fillText(label, x, xAxisY + 6);
      }
    }
  }
</script>
</body>
</html>
