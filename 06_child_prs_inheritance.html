<!--
Interactive science demo.
Part of the "science-demos" project.

GitHub: https://github.com/yupic/science-demos
YouTube: https://www.youtube.com/@autism-ru
Telegram: https://t.me/autism_science
License: MIT
-->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Наследование PRS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <script src="sd.js"></script>
</head>
<body>
<div class="container">
  <h1>Как PRS ребёнка зависит от родителей</h1>
  <p class="desc">Нормальные распределения PRS для популяции и гипотетического ребёнка. Изменяйте PRS родителей, чтобы увидеть смещение среднего ребёнка.</p>
  <div class="controls">
    <label class="slider-label">Математическое ожидание:
      <input type="number" id="meanInput" step="0.1" value="100" />
    </label>
    <label class="slider-label">Стандартное отклонение:
      <input type="number" id="sdInput" step="0.1" value="15" min="0.0001" />
    </label>
    <label class="slider-label">Мать:
      <input type="range" id="motherInput" min="60" max="140" step="1" value="100" />
      <span id="motherValue" class="slider-value">100</span>
    </label>
    <label class="slider-label">Отец:
      <input type="range" id="fatherInput" min="60" max="140" step="1" value="100" />
      <span id="fatherValue" class="slider-value">100</span>
    </label>
  </div>
  <div class="canvas-frame">
    <canvas id="prsCanvas"></canvas>
  </div>
</div>
<footer class="footer">
  © autism_science • MIT License •
  <a href="https://github.com/yupic/science-demos" target="_blank" rel="noopener">GitHub</a> •
  <a href="https://www.youtube.com/@autism-ru" target="_blank" rel="noopener">YouTube</a> •
  <a href="https://t.me/autism_science" target="_blank" rel="noopener">Telegram</a>
</footer>
<script>
  const canvas = document.getElementById('prsCanvas');
  const ctx = canvas.getContext('2d');
  const meanInput = document.getElementById('meanInput');
  const sdInput = document.getElementById('sdInput');
  const motherInput = document.getElementById('motherInput');
  const fatherInput = document.getElementById('fatherInput');
  const motherValue = document.getElementById('motherValue');
  const fatherValue = document.getElementById('fatherValue');

  const colors = {
    population: 'rgba(44, 123, 229, 0.75)',
    child: 'rgba(227, 52, 47, 0.75)',
    mother: 'rgba(147, 51, 234, 0.9)',
    father: 'rgba(16, 185, 129, 0.9)'
  };

  function normalPdf(x, mean, sigma) {
    const coef = 1 / (sigma * Math.sqrt(2 * Math.PI));
    const z = (x - mean) / sigma;
    return coef * Math.exp(-0.5 * z * z);
  }

  function normalCdf(x, mean, sigma) {
    const z = (x - mean) / (sigma * Math.sqrt(2));
    const sign = z < 0 ? -1 : 1;
    const absZ = Math.abs(z);
    const t = 1 / (1 + 0.3275911 * absZ);
    const coefficients = [0.254829592, -0.284496736, 1.421413741, -1.453152027, 1.061405429];
    const erf =
      1 -
      (((((coefficients[4] * t + coefficients[3]) * t + coefficients[2]) * t + coefficients[1]) * t + coefficients[0]) *
        t *
        Math.exp(-absZ * absZ));
    const erfValue = sign * erf;
    return 0.5 * (1 + erfValue);
  }

  function formatFromStep(value, step) {
    if (!Number.isFinite(step) || step <= 0) return value.toFixed(0);
    const decimals = step >= 1 ? 0 : Math.max(0, Math.min(6, Math.ceil(-Math.log10(step))));
    return Number(value).toFixed(decimals);
  }

  function getPopulationMean() {
    const val = Number(meanInput.value);
    if (!Number.isFinite(val)) {
      meanInput.value = 100;
      return 100;
    }
    return val;
  }

  function getPopulationSigma() {
    const val = Number(sdInput.value);
    if (!Number.isFinite(val) || val <= 0) {
      sdInput.value = 15;
      return 15;
    }
    return val;
  }

  function computeSliderStep(sigma) {
    const range = 6 * sigma;
    if (!Number.isFinite(range) || range <= 0) return 1;
    const candidates = [];
    for (let exp = -10; exp <= 10; exp++) {
      const step = 10 ** exp;
      const divisions = range / step;
      if (divisions >= 10 && divisions <= 200) {
        candidates.push({ step, divisions });
      }
    }

    if (candidates.length) {
      return candidates.reduce(
        (best, current) => {
          const score = Math.abs(current.divisions - 100);
          if (score < best.score) return { step: current.step, score };
          return best;
        },
        { step: candidates[0].step, score: Math.abs(candidates[0].divisions - 100) }
      ).step;
    }

    const approx = range / 100;
    const exp = Math.round(Math.log10(Math.max(approx, 1e-8)));
    return 10 ** exp;
  }

  function updateSliderBounds() {
    const mean = getPopulationMean();
    const sigma = getPopulationSigma();
    const min = mean - 3 * sigma;
    const max = mean + 3 * sigma;
    const step = computeSliderStep(sigma);

    [motherInput, fatherInput].forEach((input) => {
      input.min = min;
      input.max = max;
      input.step = step;
      const current = Number(input.value);
      let value = current;
      if (!Number.isFinite(value)) value = mean;
      value = Math.min(Math.max(value, min), max);
      input.value = value;
    });

    return { mean, sigma, step };
  }

  function updateLabels(step) {
    const sliderStep = step ?? (Number(motherInput.step) || 1);
    motherValue.textContent = formatFromStep(motherInput.value, sliderStep);
    fatherValue.textContent = formatFromStep(fatherInput.value, sliderStep);
  }

  function draw() {
    const { mean: populationMean, sigma: populationSigma, step: sliderStep } = updateSliderBounds();
    const motherMean = Number(motherInput.value);
    const fatherMean = Number(fatherInput.value);
    const childMean = (motherMean + fatherMean) / 2;
    const childSigma = Math.sqrt(0.5) * populationSigma;
    const xMin = populationMean - 4 * populationSigma;
    const xMax = populationMean + 4 * populationSigma;

    updateLabels(sliderStep);

    const dpr = window.devicePixelRatio || 1;
    const displayWidth = canvas.clientWidth || canvas.parentElement.clientWidth || 600;
    const targetHeight = Math.max(360, Math.min(window.innerHeight * 0.7, 560));
    canvas.style.height = `${targetHeight}px`;
    canvas.width = Math.floor(displayWidth * dpr);
    canvas.height = Math.floor(targetHeight * dpr);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    const marginLeft = 64;
    const marginRight = 16;
    const marginBottom = 40;
    const marginTop = 16;
    const dividerGap = 28 + marginTop;
    const innerWidth = width - marginLeft - marginRight;
    const innerHeightTotal = height - marginTop - marginBottom;
    const panelHeight = (innerHeightTotal - dividerGap) / 2;
    const childPanel = { y: marginTop, height: panelHeight };
    const populationPanel = { y: marginTop + panelHeight + dividerGap, height: panelHeight };

    const sampling = 400;
    const step = (xMax - xMin) / (sampling - 1);
    const populationPoints = [];
    const childPoints = [];
    for (let i = 0; i < sampling; i++) {
      const x = xMin + step * i;
      populationPoints.push({ x, y: normalPdf(x, populationMean, populationSigma) });
      childPoints.push({ x, y: normalPdf(x, childMean, childSigma) });
    }

    const maxChildY = Math.max(...childPoints.map((p) => p.y), 1e-6);
    const maxPopulationY = Math.max(...populationPoints.map((p) => p.y), 1e-6);

    const { ticks: childYTicks, maxValue: childYMax } = generateYTicks(maxChildY);
    const { ticks: populationYTicks, maxValue: populationYMax } = generateYTicks(maxPopulationY);
    const scaleX = innerWidth / (xMax - xMin);

    drawPopulationBands({
      marginLeft,
      innerWidth,
      panel: populationPanel,
      mean: populationMean,
      sigma: populationSigma,
      xMin,
      xMax
    });

    drawPopulationBands({
      marginLeft,
      innerWidth,
      panel: childPanel,
      mean: childMean,
      sigma: childSigma,
      xMin,
      xMax
    });

    drawBandProbabilities({
      mean: populationMean,
      sigma: populationSigma,
      panel: populationPanel,
      marginLeft,
      innerWidth,
      xMin,
      xMax
    });

    drawBandProbabilities({
      mean: childMean,
      sigma: childSigma,
      panel: childPanel,
      marginLeft,
      innerWidth,
      xMin,
      xMax
    });

    drawCurve({
      points: childPoints,
      color: colors.child,
      width: 2,
      panel: childPanel,
      scaleX,
      xMin,
      yMax: childYMax,
      marginLeft
    });

    drawCurve({
      points: populationPoints,
      color: colors.population,
      width: 4,
      panel: populationPanel,
      scaleX,
      xMin,
      yMax: populationYMax,
      marginLeft
    });

    drawSigmaLines({
      mean: childMean,
      sigma: childSigma,
      color: colors.child,
      panel: childPanel,
      xMin,
      xMax,
      marginLeft,
      innerWidth
    });

    drawChildProbabilities({
      childMean,
      childSigma,
      panel: childPanel,
      marginLeft,
      innerWidth,
      xMin,
      xMax,
      populationMean,
      populationSigma
    });

    drawSigmaLines({
      mean: populationMean,
      sigma: populationSigma,
      color: colors.population,
      panel: populationPanel,
      xMin,
      xMax,
      marginLeft,
      innerWidth
    });

    drawParentMarkers(
      [
        { value: motherMean, label: 'Мать', color: colors.mother },
        { value: fatherMean, label: 'Отец', color: colors.father }
      ],
      { xMin, xMax, marginLeft, innerWidth, panel: populationPanel, step: sliderStep }
    );

    drawAxes({
      xMin,
      xMax,
      marginLeft,
      innerWidth,
      panel: childPanel,
      marginRight,
      yTicks: childYTicks,
      yMax: childYMax,
      showXAxis: false,
      yLabel: 'Плотность'
    });

    drawAxes({
      xMin,
      xMax,
      marginLeft,
      innerWidth,
      panel: populationPanel,
      marginRight,
      yTicks: populationYTicks,
      yMax: populationYMax,
      showXAxis: true,
      yLabel: 'Плотность'
    });

    const dividerY = marginTop + panelHeight + dividerGap / 2;
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(marginLeft, dividerY);
    ctx.lineTo(width - marginRight, dividerY);
    ctx.stroke();

    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  function drawSigmaLines({
    mean,
    sigma,
    color,
    panel,
    xMin,
    xMax,
    marginLeft,
    innerWidth
  }) {
    const xRange = xMax - xMin;
    const lineTop = panel.y + 36;
    if (!Number.isFinite(mean) || !Number.isFinite(sigma)) return;
    const lineColor = color.replace('0.75', '0.95');
    const levels = [1, 2, 3];
    ctx.lineWidth = 1;
    levels.forEach((k) => {
      const positions = [mean - sigma * k, mean + sigma * k];
      positions.forEach((actualPos) => {
        const x = marginLeft + ((actualPos - xMin) / xRange) * innerWidth;
        if (x < marginLeft || x > marginLeft + innerWidth) return;
        const sign = actualPos < mean ? '-' : '+';
        ctx.strokeStyle = lineColor;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(x, lineTop);
        ctx.lineTo(x, panel.y + panel.height);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = lineColor;
        ctx.font = '15px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(`${sign}${k}σ`, x, panel.y + 2);
        ctx.fillText(actualPos.toFixed(1), x, panel.y + 20);
      });
    });
    const meanX = marginLeft + ((mean - xMin) / xRange) * innerWidth;
    if (meanX >= marginLeft && meanX <= marginLeft + innerWidth) {
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1.5;
      ctx.setLineDash([2, 6]);
      ctx.beginPath();
      ctx.moveTo(meanX, panel.y);
      ctx.lineTo(meanX, panel.y + panel.height);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  motherInput.addEventListener('input', draw);
  fatherInput.addEventListener('input', draw);
  meanInput.addEventListener('input', draw);
  sdInput.addEventListener('input', draw);

  draw();

  function drawPopulationBands({ marginLeft, innerWidth, panel, mean, sigma, xMin, xMax }) {
    const bands = [
      { from: -Infinity, to: mean - 3 * sigma, color: '#ffe3e6' },
      { from: mean + 3 * sigma, to: Infinity, color: '#ffe3e6' },
      { from: mean - 3 * sigma, to: mean - 2 * sigma, color: '#ffeacc' },
      { from: mean + 2 * sigma, to: mean + 3 * sigma, color: '#ffeacc' },
      { from: mean - 2 * sigma, to: mean - 1 * sigma, color: '#eaf6e5' },
      { from: mean + 1 * sigma, to: mean + 2 * sigma, color: '#eaf6e5' },
      { from: mean - 1 * sigma, to: mean + 1 * sigma, color: '#e3ecff' }
    ];

    bands.forEach(({ from, to, color }) => {
      const clampedFrom = Math.max(from, xMin);
      const clampedTo = Math.min(to, xMax);
      if (clampedTo <= clampedFrom) return;
      const xStart = marginLeft + ((clampedFrom - xMin) / (xMax - xMin)) * innerWidth;
      const width = ((clampedTo - clampedFrom) / (xMax - xMin)) * innerWidth;
      ctx.fillStyle = color;
      ctx.fillRect(xStart, panel.y, width, panel.height);
    });
  }

  function drawCurve({ points, color, width, panel, scaleX, xMin, yMax, marginLeft }) {
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.beginPath();
    points.forEach((pt, idx) => {
      const x = marginLeft + (pt.x - xMin) * scaleX;
      const y = panel.y + panel.height - (pt.y / yMax) * panel.height;
      if (idx === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }

  function drawParentMarkers(parents, { xMin, xMax, marginLeft, innerWidth, panel, step }) {
    const xRange = xMax - xMin;
    const markers = parents
      .map(({ value, label, color }) => {
        const x = marginLeft + ((value - xMin) / xRange) * innerWidth;
        return { value, label, color, x };
      })
      .filter(({ value, x }) => Number.isFinite(value) && x >= marginLeft && x <= marginLeft + innerWidth);

    markers.forEach(({ x, color }) => {
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.moveTo(x, panel.y);
      ctx.lineTo(x, panel.y + panel.height);
      ctx.stroke();
      ctx.setLineDash([]);
    });

    if (!markers.length) return;

    const labelY = Math.max(16, panel.y - 4);
    const gap = 8;
    const font = '15px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.font = font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';

    const items = markers.map((marker) => {
      const textValue = formatFromStep(marker.value, step || 1);
      const text = `${marker.label}: ${textValue}`;
      const metrics = ctx.measureText(text);
      const width = metrics.width;
      const height = 16;
      return { ...marker, text, width, height };
    });

    const overlaps = (a, b) => a.x - a.width / 2 <= b.x + b.width / 2 && b.x - b.width / 2 <= a.x + a.width / 2;

    let positions = items.map((item) => ({ ...item, drawX: item.x, drawY: labelY }));

    if (positions.length >= 2 && overlaps(positions[0], positions[1])) {
      const ordered = positions
        .slice()
        .sort((a, b) => {
          if (a.value === b.value) {
            if (a.label === b.label) return 0;
            return a.label === 'Мать' ? -1 : 1;
          }
          return a.value - b.value;
        });

      const totalWidth = ordered[0].width + gap + ordered[1].width;
      const center = (ordered[0].x + ordered[1].x) / 2;
      ordered[0].drawX = center - totalWidth / 2 + ordered[0].width / 2;
      ordered[1].drawX = center + totalWidth / 2 - ordered[1].width / 2;
      positions = ordered;
    }

    positions.forEach((item) => {
      ctx.fillStyle = item.color;
      ctx.fillText(item.text, item.drawX, item.drawY);
    });
  }

  function drawChildProbabilities({
    childMean,
    childSigma,
    panel,
    marginLeft,
    innerWidth,
    xMin,
    xMax,
    populationMean,
    populationSigma
  }) {
    const a = populationMean - 3 * populationSigma;
    const b = populationMean - 2 * populationSigma;
    const probA = normalCdf(a, childMean, childSigma);
    const probB = normalCdf(b, childMean, childSigma);

    const clamp = (value) => Math.min(Math.max(value, xMin), xMax);
    const xRange = xMax - xMin;
    const toCanvasX = (val) => marginLeft + ((val - xMin) / xRange) * innerWidth;

    const labels = [
      { x: clamp(a), value: probA },
      { x: clamp(b), value: probB }
    ];

    ctx.fillStyle = '#444';
    ctx.font = '13px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    const y = panel.y + panel.height + 6;
    labels.forEach(({ x, value }) => {
      ctx.fillText(`${(value * 100).toFixed(2)}%`, toCanvasX(x), y);
    });
  }

  function drawAxes({
    xMin,
    xMax,
    marginLeft,
    innerWidth,
    panel,
    marginRight,
    yTicks,
    yMax,
    showXAxis,
    yLabel
  }) {
    const y0 = panel.y + panel.height;
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(marginLeft, y0);
    ctx.lineTo(marginLeft, panel.y);
    ctx.stroke();

    ctx.fillStyle = '#444';
    ctx.font = '12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    yTicks.forEach((tick) => {
      const y = panel.y + panel.height - (tick / yMax) * panel.height;
      ctx.beginPath();
      ctx.moveTo(marginLeft - 4, y);
      ctx.lineTo(marginLeft, y);
      ctx.stroke();
      ctx.fillText(tick.toFixed(4), marginLeft - 6, y);
    });

    ctx.save();
    ctx.translate(10, panel.y + panel.height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    if (showXAxis) {
      const xRange = xMax - xMin || 1;
      const xAxisY = panel.y + panel.height;

      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(marginLeft, xAxisY);
      ctx.lineTo(marginLeft + innerWidth, xAxisY);
      ctx.stroke();

      ctx.fillStyle = '#444';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      const labelValues = generateXTicks({ min: xMin, max: xMax }, innerWidth);
      const stepForFormat = labelValues.length >= 2 ? Math.abs(labelValues[1] - labelValues[0]) : 1;
      const decimals = stepForFormat >= 1 ? 0 : Math.max(0, Math.min(6, Math.ceil(-Math.log10(stepForFormat))));
      const formatTick = (value) => {
        if (decimals === 0) return Math.round(value).toString();
        return Number(value.toFixed(decimals)).toString();
      };

      for (const value of labelValues) {
        const x = marginLeft + ((value - xMin) / xRange) * innerWidth;
        const label = formatTick(value);
        ctx.beginPath();
        ctx.moveTo(x, xAxisY);
        ctx.lineTo(x, xAxisY + 4);
        ctx.stroke();
        ctx.fillText(label, x, xAxisY + 6);
      }
    }
  }

  function drawBandProbabilities({ mean, sigma, panel, marginLeft, innerWidth, xMin, xMax }) {
    const boundaries = [
      -Infinity,
      mean - 3 * sigma,
      mean - 2 * sigma,
      mean - 1 * sigma,
      mean,
      mean + 1 * sigma,
      mean + 2 * sigma,
      mean + 3 * sigma,
      Infinity
    ];

    const xRange = xMax - xMin;
    const centerY = panel.y + panel.height / 2;
    ctx.fillStyle = 'rgba(60, 60, 60, 0.3)';
    ctx.font = '24px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let i = 0; i < boundaries.length - 1; i++) {
      const left = boundaries[i];
      const right = boundaries[i + 1];
      const leftProb = left === -Infinity ? 0 : normalCdf(left, mean, sigma);
      const rightProb = right === Infinity ? 1 : normalCdf(right, mean, sigma);
      const prob = rightProb - leftProb;

      const clampedLeft = Math.max(left, xMin);
      const clampedRight = Math.min(right, xMax);
      if (clampedRight <= clampedLeft) continue;
      const centerXValue = clampedLeft + (clampedRight - clampedLeft) / 2;
      const centerX = marginLeft + ((centerXValue - xMin) / xRange) * innerWidth;
      ctx.fillText(`${(prob * 100).toFixed(2)}%`, centerX, centerY);
    }
  }
</script>
</body>
</html>
