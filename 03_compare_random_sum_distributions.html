<!--
Interactive science demo.
Part of the "science-demos" project.

GitHub: https://github.com/yupic/science-demos
YouTube: https://www.youtube.com/@autism-ru
Telegram: https://t.me/autism_science
License: MIT
-->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Суммы случайных чисел</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <script src="sd.js"></script>
</head>
<body>
<div class="container">
  <h1>Гистограмма суммы случайных чисел</h1>
  <p class="desc">Построение графиков распределения суммы из <strong>N</strong> случайных <i>целых</i> чисел из диапазона от <strong>min</strong> до <strong>max</strong>.</p>
  <div class="controls">
    <label class="mut-label">Масштаб:
      <select id="scaleMode">
        <option value="full" selected>Полный</option>
        <option value="auto">Авто</option>
      </select>
    </label>
    <label class="mut-label">Добавить/удалить гистограмму:</label>
    <div class="prob-actions">
      <button id="addSetBtn">➕</button>
      <button id="removeSetBtn" disabled>❌</button>
    </div>
  </div>
  <div class="probability-section">
    <div class="probability-list" id="setList"></div>
  </div>
  <div class="canvas-frame">
    <canvas id="histCanvas"></canvas>
  </div>
</div>
<footer class="footer">
  © autism_science • MIT License •
  <a href="https://github.com/yupic/science-demos" target="_blank" rel="noopener">GitHub</a> •
  <a href="https://www.youtube.com/@autism-ru" target="_blank" rel="noopener">YouTube</a> •
  <a href="https://t.me/autism_science" target="_blank" rel="noopener">Telegram</a>
</footer>
<script>
  const canvas = document.getElementById('histCanvas');
  const ctx = canvas.getContext('2d');
  const scaleModeSelect = document.getElementById('scaleMode');
  const addSetBtn = document.getElementById('addSetBtn');
  const removeSetBtn = document.getElementById('removeSetBtn');
  const setList = document.getElementById('setList');

  const colors = [
    'rgba(44, 123, 229, 0.5)',
    'rgba(227, 52, 47, 0.5)',
    'rgba(52, 168, 83, 0.5)',
    'rgba(255, 193, 7, 0.5)',
    'rgba(156, 39, 176, 0.5)',
    'rgba(0, 188, 212, 0.5)',
    'rgba(255, 87, 34, 0.5)'
  ];

  let datasets = [];
  let scaleMode = 'full';
  let currentRange = { min: 0, max: 100 };
  let hoveredValue = null;

  function uniformSumPmf(count, minValue, maxValue) {
    if (count <= 0) {
      return { probs: [1], offset: 0 };
    }
    const low = Math.min(minValue, maxValue);
    const high = Math.max(minValue, maxValue);
    const width = high - low + 1;
    const baseProb = 1 / width;
    let probs = new Float64Array(width).fill(baseProb);
    let offset = low;

    for (let i = 1; i < count; i++) {
      const next = new Float64Array(probs.length + width - 1);
      for (let a = 0; a < probs.length; a++) {
        const p = probs[a];
        if (p === 0) continue;
        for (let b = 0; b < width; b++) {
          next[a + b] += p * baseProb;
        }
      }
      probs = next;
      offset += low;
    }

    return { probs: Array.from(probs), offset };
  }

  function calculateRange(simulatedDatasets, fallbackRange) {
    if (!simulatedDatasets || simulatedDatasets.length === 0) return fallbackRange;

    if (scaleMode !== 'auto') {
      let minOverall = Infinity;
      let maxOverall = -Infinity;
      simulatedDatasets.forEach(({ theoreticalMin, theoreticalMax }) => {
        minOverall = Math.min(minOverall, theoreticalMin);
        maxOverall = Math.max(maxOverall, theoreticalMax);
      });
      if (!Number.isFinite(minOverall) || !Number.isFinite(maxOverall)) return fallbackRange;
      return { min: minOverall, max: maxOverall };
    }

    let minObserved = Infinity;
    let maxObserved = -Infinity;
    simulatedDatasets.forEach((dataset) => {
      const { mean, sigma, theoreticalMin, theoreticalMax, probs, offset } = dataset;
      if (Number.isFinite(mean) && Number.isFinite(sigma)) {
        const spread = Math.max(1, sigma * 4);
        minObserved = Math.min(minObserved, Math.max(theoreticalMin, Math.floor(mean - spread)));
        maxObserved = Math.max(maxObserved, Math.min(theoreticalMax, Math.ceil(mean + spread)));
        return;
      }
      if (!probs) return;
      for (let i = 0; i < probs.length; i++) {
        if (probs[i] > 0) {
          const value = offset + i;
          minObserved = Math.min(minObserved, value);
          maxObserved = Math.max(maxObserved, value);
        }
      }
    });

    if (!Number.isFinite(minObserved) || !Number.isFinite(maxObserved)) return fallbackRange;
    if (minObserved === maxObserved) {
      return { min: minObserved - 1, max: maxObserved + 1 };
    }
    return { min: minObserved, max: maxObserved };
  }

  function draw(simulatedDatasets) {
    const fallbackRange = simulatedDatasets?.[0]
      ? { min: simulatedDatasets[0].theoreticalMin, max: simulatedDatasets[0].theoreticalMax }
      : { min: 0, max: 100 };

    const { min: xMin, max: xMax } = calculateRange(simulatedDatasets, fallbackRange);
    currentRange = { min: xMin, max: xMax };
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;
    const dpr = window.devicePixelRatio || 1;
    const displayWidth = canvas.clientWidth || canvas.parentElement.clientWidth || 600;
    const targetHeight = Math.max(280, Math.min(window.innerHeight * 0.6, 520));
    canvas.style.height = `${targetHeight}px`;
    canvas.width = Math.floor(displayWidth * dpr);
    canvas.height = Math.floor(targetHeight * dpr);

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    const marginLeft = 64;
    const marginRight = 16;
    const marginBottom = 40;
    const marginTop = 18;
    const innerWidth = width - marginLeft - marginRight;
    const innerHeight = height - marginTop - marginBottom;

    ctx.fillStyle = '#f8f9fc';
    ctx.fillRect(marginLeft, marginTop, innerWidth, innerHeight);

    if (!simulatedDatasets || simulatedDatasets.length === 0) {
      drawAxesOnly(ctx, { xMin, xMax, marginLeft, marginTop, innerWidth, innerHeight, width, height });
      return;
    }

    let globalMaxProb = 0;
    simulatedDatasets.forEach(({ probs }) => {
      const maxProb = Math.max(...probs, 0);
      globalMaxProb = Math.max(globalMaxProb, maxProb);
    });

    const { ticks: yTicks, maxValue: yMax } = generateYTicks(globalMaxProb);
    const scaleY = yMax > 0 ? innerHeight / yMax : 0;

    simulatedDatasets.forEach(({ probs, offset, color }) => {
      ctx.fillStyle = color;
      const barWidth = innerWidth / xRange;
      for (let i = 0; i < probs.length; i++) {
        const prob = probs[i];
        if (prob === 0) continue;
        const xValue = offset + i;
        const xLeft = marginLeft + ((xValue - 0.5 - xMinEdge) / xRange) * innerWidth;
        const h = prob * scaleY;
        if (h < 1) continue;
        const y = marginTop + innerHeight - h;
        if (xLeft + barWidth < marginLeft || xLeft > width - marginRight) continue;
        const drawWidth = Math.max(1, barWidth * 0.9);
        const x = xLeft + (barWidth - drawWidth) / 2;
        ctx.fillRect(x, y, drawWidth, h);
      }
    });

    drawSigmaLines(simulatedDatasets, { xMinEdge, xRange, marginLeft, innerWidth, marginTop, innerHeight });
    drawAxesOnly(ctx, { xMin, xMax, marginLeft, marginTop, innerWidth, innerHeight, width, height, yTicks, yMax });
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  function drawSigmaLines(simulatedDatasets, { xMinEdge, xRange, marginLeft, innerWidth, marginTop, innerHeight }) {
    const lineTop = marginTop + 36;
    simulatedDatasets.forEach(({ mean, sigma, color }) => {
      if (!Number.isFinite(mean) || !Number.isFinite(sigma)) return;
      const lineColor = color.replace('0.5', '0.9');
      const levels = [1, 2, 3];
      ctx.lineWidth = 1;
      levels.forEach((k) => {
        const positions = [mean - sigma * k, mean + sigma * k];
        positions.forEach((actualPos) => {
          const basePos = actualPos < mean ? Math.ceil(actualPos) : (actualPos > mean ? Math.floor(actualPos) : actualPos);
          const shiftedPos = basePos + (actualPos < mean ? -0.5 : (actualPos > mean ? 0.5 : 0));
          const x = marginLeft + ((shiftedPos - xMinEdge) / xRange) * innerWidth;
          if (x < marginLeft || x > marginLeft + innerWidth) return;
          const sign = actualPos < mean ? '-' : '+';
          ctx.strokeStyle = lineColor;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(x, lineTop);
          ctx.lineTo(x, marginTop + innerHeight);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.fillStyle = '#222';
          ctx.font = '15px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(`${sign}${k}σ`, x, marginTop + 2);
          ctx.fillText(actualPos.toFixed(1), x, marginTop + 20);
        });
      });
      const meanX = marginLeft + (((mean) - xMinEdge) / xRange) * innerWidth;
      if (meanX >= marginLeft && meanX <= marginLeft + innerWidth) {
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = 1.5;
        ctx.setLineDash([2, 6]);
        ctx.beginPath();
        ctx.moveTo(meanX, marginTop);
        ctx.lineTo(meanX, marginTop + innerHeight);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    });
  }

  function createSetRow(defaults = { count: 100, min: 0, max: 1 }) {
    const row = document.createElement('div');
    row.className = 'probability-row';
    const colorDot = document.createElement('div');
    colorDot.className = 'color-dot';
    const color = colors[setList.children.length % colors.length];
    colorDot.style.background = color;

    const countLabel = document.createElement('label');
    countLabel.className = 'mut-label';
    countLabel.textContent = 'N:';
    const countInput = document.createElement('input');
    countInput.type = 'number';
    countInput.min = '1';
    countInput.max = '300';
    countInput.value = clampInt(defaults.count, 1, 300, 100);
    countInput.addEventListener('input', handleCreate);
    countLabel.appendChild(countInput);

    const minLabel = document.createElement('label');
    minLabel.className = 'mut-label';
    minLabel.textContent = 'min:';
    const minInput = document.createElement('input');
    minInput.type = 'number';
    minInput.min = '-50';
    minInput.max = '50';
    minInput.value = clampInt(defaults.min, -50, 50, 0);
    minInput.addEventListener('input', handleCreate);
    minLabel.appendChild(minInput);

    const maxLabel = document.createElement('label');
    maxLabel.className = 'mut-label';
    maxLabel.textContent = 'max:';
    const maxInput = document.createElement('input');
    maxInput.type = 'number';
    maxInput.min = '-50';
    maxInput.max = '50';
    maxInput.value = clampInt(defaults.max, -50, 50, 1);
    maxInput.addEventListener('input', handleCreate);
    maxLabel.appendChild(maxInput);

    const stats = document.createElement('span');
    stats.className = 'prob-display';
    stats.style.fontSize = '12px';
    stats.style.color = '#444';

    const info = document.createElement('span');
    info.className = 'prob-info';
    info.style.fontSize = '12px';
    info.style.color = '#555';
    info.textContent = '';

    row.appendChild(colorDot);
    row.appendChild(countLabel);
    row.appendChild(minLabel);
    row.appendChild(maxLabel);
    row.appendChild(stats);
    row.appendChild(info);
    setList.appendChild(row);
  }

  function refreshColorDots() {
    Array.from(setList.children).forEach((row, idx) => {
      const dot = row.querySelector('.color-dot');
      dot.style.background = colors[idx % colors.length];
    });
  }

  function updateRemoveButtonState() {
    removeSetBtn.disabled = setList.children.length <= 1;
  }

  function collectSets() {
    const sets = [];
    Array.from(setList.children).forEach((row, idx) => {
      const inputs = row.querySelectorAll('input');
      const count = clampInt(inputs[0]?.value, 1, 300, 100);
      const minValue = clampInt(inputs[1]?.value, -50, 50, 0);
      let maxValue = clampInt(inputs[2]?.value, -50, 50, 1);
      if (maxValue < minValue) {
        maxValue = minValue;
      }
      inputs[0].value = count;
      inputs[1].value = minValue;
      inputs[2].value = maxValue;
      const color = colors[idx % colors.length];
      sets.push({ count, min: minValue, max: maxValue, color, row });
    });
    return sets;
  }

  function updateStatsDisplay(simulatedDatasets) {
    Array.from(setList.children).forEach((row, idx) => {
      const stats = row.querySelector('.prob-display');
      const info = row.querySelector('.prob-info');
      const data = simulatedDatasets?.[idx];
      if (!stats || !data) {
        if (stats) stats.textContent = '';
        if (info) info.textContent = '';
        return;
      }
      stats.innerHTML = `| Среднее: <span class="value-strong">${data.mean.toFixed(2)}</span> | σ: <span class="value-strong">${data.sigma.toFixed(1)}</span>`;
    });
    updateHoverInfo(hoveredValue);
  }

  function updateHoverInfo(value = hoveredValue) {
    if (!datasets.length) {
      Array.from(setList.children).forEach((row) => {
        const info = row.querySelector('.prob-info');
        if (info) info.textContent = '';
      });
      return;
    }

    Array.from(setList.children).forEach((row, idx) => {
      const info = row.querySelector('.prob-info');
      const dataset = datasets[idx];
      if (!info || !dataset) {
        if (info) info.textContent = '';
        return;
      }

      if (value === null) {
        info.textContent = '';
        return;
      }

      const maxIndex = dataset.probs.length - 1;
      const minValue = dataset.offset;
      const maxValue = dataset.offset + maxIndex;
      const clampedValue = Math.max(minValue, Math.min(maxValue, value));
      const relativeIndex = Math.round(clampedValue - dataset.offset);
      const prob = dataset.probs[relativeIndex] || 0;
      if (prob < 0.0001) {
        info.textContent = '';
        return;
      }
      info.innerHTML = `| Сумма: <span class="value-strong">${dataset.offset + relativeIndex}</span> | Вероятность: <span class="value-strong">${(prob * 100).toFixed(2)}%</span>`;
    });
  }

  function handleMouseMove(event) {
    if (!datasets.length) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const marginLeft = 64;
    const marginRight = 16;
    const innerWidth = rect.width - marginLeft - marginRight;
    const xMinEdge = currentRange.min - 0.5;
    const xMaxEdge = currentRange.max + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;

    if (x < marginLeft || x > rect.width - marginRight) {
      hoveredValue = null;
      updateHoverInfo();
      return;
    }

    const value = xMinEdge + ((x - marginLeft) / innerWidth) * xRange;
    hoveredValue = Math.round(value);
    updateHoverInfo(hoveredValue);
  }

  function handleMouseLeave() {
    hoveredValue = null;
    updateHoverInfo();
  }

  function handleCreate() {
    const sets = collectSets();
    if (sets.length === 0) {
      createSetRow();
      return;
    }

    const simulatedDatasets = sets.map(({ count, min, max, color }) => {
      const { probs, offset } = uniformSumPmf(count, min, max);
      const average = (min + max) / 2;
      const varianceSingle = ((Math.pow(max - min + 1, 2) - 1) / 12);
      const variance = varianceSingle * count;
      const sigma = Math.sqrt(variance);
      const mean = average * count;
      const theoreticalMin = count * Math.min(min, max);
      const theoreticalMax = count * Math.max(min, max);
      return { probs, offset, color, mean, sigma, theoreticalMin, theoreticalMax };
    });

    datasets = simulatedDatasets;
    updateStatsDisplay(simulatedDatasets);
    draw(simulatedDatasets);
  }

  addSetBtn.addEventListener('click', () => {
    createSetRow();
    refreshColorDots();
    updateRemoveButtonState();
    handleCreate();
  });

  removeSetBtn.addEventListener('click', () => {
    const rows = setList.children;
    if (rows.length <= 1) return;
    setList.removeChild(rows[rows.length - 1]);
    refreshColorDots();
    updateRemoveButtonState();
    handleCreate();
  });

  scaleModeSelect.addEventListener('change', (e) => {
    scaleMode = e.target.value;
    draw(datasets);
  });

  window.addEventListener('resize', () => draw(datasets));
  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mouseleave', handleMouseLeave);

  createSetRow();
  updateRemoveButtonState();
  handleCreate();
</script>
</body>
</html>
