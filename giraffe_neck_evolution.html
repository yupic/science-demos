<!--
Interactive science demo.
Part of the "science-demos" project.

GitHub: https://github.com/yupic/science-demos
YouTube: https://www.youtube.com/@autism-ru
Telegram: https://t.me/autism_science
License: MIT
-->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Эволюция длины шеи жирафа</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <style>
    .instruction-card {
      padding: 0;
      max-width: 989px;
    }

    .canvas-frame.intrinsic-size {
      width: auto;
      max-width: 100%;
    }

    .canvas-frame.intrinsic-size canvas {
      width: auto;
      height: auto;
      max-width: 100%;
    }

    .instruction-summary {
      cursor: pointer;
      padding: 8px;
      font-weight: 600;
      list-style: none;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      user-select: none;
    }

    .instruction-summary::marker,
    .instruction-summary::-webkit-details-marker {
      display: none;
    }

    .instruction-summary::before {
      content: '▶';
      font-size: 13px;
      transition: transform 0.2s ease;
      color: var(--muted);
    }

    details[open] .instruction-summary::before {
      content: '▼';
      color: var(--muted);
    }

    .instruction-summary .summary-label-open {
      display: none;
    }

    details[open] .instruction-summary .summary-label-open {
      display: inline;
    }

    details[open] .instruction-summary .summary-label-closed {
      display: none;
    }

    .charts-layout {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      flex-wrap: wrap;
    }

    .charts-column {
      flex: 0 0 auto;
      width: fit-content;
      max-width: 100%;
    }

    .allele-card {
      width: 248px;
      flex-shrink: 0;
    }

    .allele-canvas {
      display: block;
    }

    .allele-legend-swatch {
      width: 14px;
      height: 14px;
      border: 1px solid var(--border);
      border-radius: 3px;
      flex-shrink: 0;
    }

    .allele-info {
      margin-top: 8px;
      font-size: 13px;
      color: var(--fg);
      line-height: 1.4;
    }

    .allele-info-title {
      font-weight: 600;
      margin-bottom: 6px;
    }

    .allele-info-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      color: var(--muted);
    }

    .allele-info-row:last-child {
      margin-bottom: 0;
    }

    .genome-card {
      margin-top: 12px;
    }

    .genome-list {
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre;
      font-size: 12px;
      line-height: 1.4;
      color: var(--fg);
    }

    .genome-letter {
      color: #00f;
    }

    .genome-letter-A {
      color: #fff;
    }

    .genome-letter-C {
      color: #000;
    }

    .genome-letter-G {
      color: #ff0;
    }

    .genome-letter-T {
      color: #00f;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Симулятор эволюции длины шеи жирафа</h1>
  <details class="card instruction-card">
    <summary class="instruction-summary">
      <span class="summary-label-closed">Развернуть описание</span>
      <span class="summary-label-open">Свернуть описание</span>
    </summary>
    <div style="padding:0 12px 12px 12px;">
      <div class="card-title">TL;DR — как смотреть на эту демку</div>
      <div class="note" style="font-size:13px; line-height:1.5; color:#444;">
        <ul>
          <li>Нажмите <strong>«Старт»</strong>, чтобы запустить эволюцию популяции из 10&nbsp;000 жирафов с «геномом» из 100 позиций.</li>
          <li>Каждый ген даёт небольшой вклад в длину шеи. Отбор предпочитает особей с длиной около <strong>150&nbsp;см</strong> и делает их родителями чаще.</li>
          <li>Верхний график показывает <strong>распределение длин шеи</strong> в текущем поколении, нижний — <strong>динамику средней длины</strong> по поколениям.</li>
          <li><strong>«Мутаций на поколение»</strong> и <strong>«Давление отбора (σ)»</strong> можно менять во время работы и смотреть, как меняется скорость и ширина эволюции.</li>
          <li>Блок «Топ-5 длинных и 5 коротких» показывает примеры геномов; тепловая карта справа — <strong>частоты букв A/C/G/T</strong> в каждой позиции. Кликайте по буквам и строкам, чтобы увидеть вклад аллелей.</li>
          <li>Это упрощённая модель: вклад генов просто складывается, взаимодействий между ними (эпистаза) нет, а мутации ускорены, чтобы эволюция была заметна «на глазах».</li>
        </ul>
      </div>

      <div class="card-title">Как устроена эта модель</div>
      <div class="note" style="font-size:13px; line-height:1.5; color:#444;">
        <p><strong>Что здесь моделируется</strong></p>
        <ul>
          <li>В популяции всегда <strong>10&nbsp;000 особей</strong>.</li>
          <li>У каждой особи есть «геном» длиной <strong>100 позиций</strong>. В каждой позиции стоит одна буква: A, C, G или T.</li>
          <li>Каждая буква в каждой позиции даёт небольшой вклад в признак — длину шеи. Сумма вкладов по всем позициям + базовое значение = длина шеи особи.</li>
          <li>Отбор стабилизирующий: есть <strong>оптимальная длина</strong> шеи (150&nbsp;см). Слишком короткие и слишком длинные шеи менее успешны.</li>
          <li>В модели вклад генов <strong>аддитивный</strong>: никаких неаддитивных взаимодействий (эпистаза) здесь нет, вклад всех позиций просто складывается.</li>
        </ul>

        <p><strong>Как отбор делает следующее поколение</strong></p>
        <ul>
          <li>У каждой особи считается «приспособленность»: чем ближе её шея к 150&nbsp;см, тем выше шанс оставить потомков.</li>
          <li>Следующее поколение собирается из потомков предыдущего:
            <ul>
              <li>Каждый новый детёныш получает геном от <strong>двух родителей</strong>: для каждой позиции случайно берётся буква либо у «мамы», либо у «папы» (перекомбинация).</li>
              <li>Родители выбираются случайно, но <strong>с весами по приспособленности</strong>: особи ближе к оптимуму чаще оказываются родителями.</li>
            </ul>
          </li>
        </ul>

        <p><strong>Мутации</strong></p>
        <ul>
          <li>После формирования нового поколения в нём случайным образом происходит некоторое <strong>число мутаций</strong> — то, что выбирается в списке «Мутаций на поколение».</li>
          <li>Каждая мутация:
            <ul>
              <li>случайно выбирает одну особь и одну позицию в её геноме;</li>
              <li>заменяет букву в этой позиции на другую (A → C/G/T и т.п.).</li>
            </ul>
          </li>
          <li>Одна такая мутация обычно сдвигает длину шеи лишь на несколько сантиметров — это <strong>мутации небольшого эффекта</strong>.</li>
          <li>В реальной эволюции мутаций у конкретного вида обычно гораздо меньше. В демо <strong>скорость мутаций специально завышена</strong>, чтобы изменения были заметны за минуты, а не за тысячи поколений.</li>
        </ul>

        <p><strong>Режимы: полигенный vs моногенный признак</strong></p>
        <ul>
          <li><strong>Полигенный</strong> (по умолчанию):
            <ul>
              <li>В каждой из 100 позиций есть <strong>4 возможные буквы</strong> с разным эффектом на длину шеи.</li>
              <li>При этом в начальной популяции на каждой позиции разрешены только <strong>2 из 4 аллелей</strong> — остальные появляются позже только через мутации.</li>
              <li>Уже в начальной популяции есть заметное генетическое разнообразие, из которого отбор «лепит» нормальное распределение.</li>
            </ul>
          </li>
          <li><strong>Моногенный</strong>:
            <ul>
              <li>В начале во всех 100 позициях стоит один «нормальный» вариант (A), дающий нулевой вклад.</li>
              <li>Все отличающиеся варианты возникают только <strong>через мутации</strong> и могут иметь как слегка полезный, так и слегка вредный эффект (обычно ±1–2&nbsp;см).</li>
              <li>Сначала у всех длина шеи ≈50&nbsp;см, вариации почти нет. Со временем, по мере накопления небольших мутаций, вокруг 50&nbsp;см начинают появляться сначала 49 и 51, потом 48 и 52 и т.д., постепенно формируя колокол распределения.</li>
              <li>Это иллюстрирует ситуацию, когда <strong>вариация признака появляется за счёт большого числа мутаций небольшого эффекта</strong>, а не из-за единичных «крупных» мутаций.</li>
            </ul>
          </li>
        </ul>

        <p><strong>Что означают графики</strong></p>
        <ul>
          <li><strong>Строка «Поколение / средняя длина / min / max / SD»</strong> под панелью управления:
            <ul>
              <li><strong>Поколение</strong> — номер текущего поколения.</li>
              <li><strong>Средняя длина</strong> — средняя длина шеи по всем 10&nbsp;000 особям.</li>
              <li><strong>min</strong> — минимальная длина шеи в популяции.</li>
              <li><strong>max</strong> — максимальная длина шеи в популяции.</li>
              <li><strong>SD</strong> — стандартное отклонение, ширина «колокола» (насколько сильно особи отличаются друг от друга).</li>
            </ul>
          </li>

          <li><strong>«Распределение длины шеи в текущем поколении»</strong> (верхний график):
            <ul>
              <li>Гистограмма показывает, сколько особей с каждой длиной шеи.</li>
              <li>По оси X — длина шеи (см), по оси Y — число особей.</li>
              <li>Под действием отбора и мутаций гистограмма обычно стремится к <strong>колоколу нормального распределения</strong>.</li>
            </ul>
          </li>

          <li><strong>«Динамика средней длины шеи»</strong> (нижний график):
            <ul>
              <li>Оранжевая линия — средняя длина шеи по поколениям.</li>
              <li>Серая пунктирная линия — оптимум 150&nbsp;см.</li>
              <li>Можно видеть, как средняя длина подходит к оптимуму и колеблется вокруг него.</li>
            </ul>
          </li>
        </ul>

        <p><strong>Топ-5 длинных и 5 коротких особей</strong></p>
        <ul>
          <li>Здесь показаны геномы нескольких самых длинношеих и нескольких самых короткошеих особей.</li>
          <li>Каждая буква раскрашена в тот же цвет, что и на тепловой карте аллелей.</li>
          <li>Число справа — длина шеи этой особи в сантиметрах.</li>
          <li>Можно <strong>кликнуть по любой букве</strong>. Это:
            <ul>
              <li>подсветит соответствующую позицию на тепловой карте;</li>
              <li>покажет подробную информацию о том, насколько каждый вариант буквы в этой позиции помогает или мешает.</li>
            </ul>
          </li>
        </ul>

        <p><strong>Тепловая карта аллелей</strong></p>
        <ul>
          <li>Каждая горизонтальная строка — <strong>одна позиция в геноме</strong> (один «ген» в модели).</li>
          <li>Длина цветных сегментов в строке показывает, какой процент популяции несёт буквы A, C, G, T в этой позиции.</li>
          <li>Например, если в какой-то позиции:
            <ul>
              <li>A у 30% особей,</li>
              <li>C у 20%,</li>
              <li>G у 0%,</li>
              <li>T у 50%,</li>
            </ul>
            то строка будет состоять примерно из 30% красного сегмента (A), 20% жёлтого (C) и 50% зелёного (T), подряд.
          </li>
          <li>Цвета:
            <ul>
              <li>A — красный, C — жёлтый, G — синий, T — зелёный.</li>
            </ul>
          </li>

          <li>В режиме <strong>полигенного признака</strong> для удобства <strong>эффекты всех четырёх букв в каждой позиции упорядочены</strong> так, что:
            <ul>
              <li>их вклад идёт по возрастанию: A ≤ C ≤ G ≤ T;</li>
              <li>в этой конкретной позиции T всегда самый «плюсующий» вариант, а A — самый «минусующий»;</li>
              <li>при этом <strong>численные значения эффекта</strong> (например, +2&nbsp;см или −1&nbsp;см) отличаются от позиции к позиции;</li>
              <li>возможны случаи, когда все буквы дают одинаковый вклад (например, A = C = G = T = −2&nbsp;см или = +2&nbsp;см).</li>
            </ul>
          </li>

          <li>В режиме <strong>моногенного признака</strong>:
            <ul>
              <li>A всегда имеет фиксированный вклад 0&nbsp;см;</li>
              <li>значения для C, G и T случайно выбираются в диапазоне от −2 до +2&nbsp;см и затем сортируются между собой так, что C ≤ G ≤ T;</li>
              <li>поэтому A может оказаться как меньше, так и больше C, G или T: A не обязательно «самая минусующая» буква и не обязательно самая «плюсующая»;</li>
              <li>возможны ситуации, когда C, G и T между собой равны (например, C = G = T = −1&nbsp;см), но A при этом остаётся 0&nbsp;см.</li>
            </ul>
          </li>

          <li>Если кликнуть по строке или перейти стрелками ↑/↓, в блоке ниже появится:
            <ul>
              <li>номер позиции;</li>
              <li>для каждой буквы — её вклад в длину шеи (в сантиметрах) и её частота в популяции.</li>
            </ul>
          </li>

          <li>Важно: тепловая карта показывает <strong>средние частоты аллелей</strong> в популяции, а не конкретный геном отдельной особи.</li>
          <li>На тепловой карте можно наблюдать динамику:
            <ul>
              <li>в позициях, где «плюсующие» аллели помогают приблизить длину шеи к 150&nbsp;см, их цветные сегменты со временем занимают всё большую долю строки;</li>
              <li>«минусующие» варианты, уводящие признак от оптимума, постепенно занимают всё меньшую долю.</li>
            </ul>
          </li>
        </ul>

        <p><strong>Кнопки и ползунки</strong></p>
        <ul>
          <li><strong>«Старт / Пауза»</strong> — запускает или останавливает эволюцию.</li>
          <li><strong>«1 шаг»</strong> — продвигает модель ровно на одно поколение вперёд.</li>
          <li><strong>«Сбросить»</strong> — полностью переинициализирует генетическую карту и создаёт новую случайную популяцию.</li>
          <li><strong>«Признак: Полигенный / Моногенный»</strong>:
            <ul>
              <li>режим можно менять только при сбросе (после смены режима популяция создаётся заново);</li>
              <li>полигенный режим даёт много вариации с самого начала, моногенный — вводит её постепенно через мутации.</li>
            </ul>
          </li>
          <li><strong>«Мутаций на поколение»</strong>:
            <ul>
              <li>задаёт <strong>ожидаемое</strong> число мутаций во всей популяции за одно поколение;</li>
              <li>чем больше значение, тем быстрее появляются новые варианты генов и тем быстрее эволюция находит новые комбинации.</li>
            </ul>
          </li>
          <li><strong>«Давление отбора (σ)»</strong>:
            <ul>
              <li>σ — ширина «горба» приспособленности вокруг оптимума;</li>
              <li><strong>маленькое σ</strong> → сильный отбор: особи, сильно отличающиеся от 150&nbsp;см, почти не размножаются;</li>
              <li><strong>большое σ</strong> → слабый отбор: популяция допускает широкий разброс длин шеи;</li>
              <li>чем меньше σ (больше давление отбора), тем сильнее различаются шансы на размножение у более и менее приспособленных особей и тем быстрее меняется длина шеи.</li>
            </ul>
          </li>
          <li>Часть параметров (<strong>число мутаций</strong>, <strong>давление отбора</strong>) можно менять прямо во время симуляции и сразу видеть, как меняется ход эволюции. Режим признака (полигенный/моногенный) меняется только при сбросе.</li>
        </ul>

        <p><strong>Что важно иметь в виду</strong></p>
        <ul>
          <li>Это <strong>игрушечная модель</strong>: один признак, упрощённый отбор, завышенные скорости мутаций и совсем маленькое число «генов» по сравнению с реальным организмом.</li>
          <li>Большой разброс длины шеи в демке (широкий колокол, далёкие значения min и max) тоже связан с упрощением. Здесь признак задаётся всего <strong>100 позициями</strong>, и вклад каждой буквы относительно крупный (до примерно ±2&nbsp;см). В реальных полигенных признаках участвуют тысячи вариантов с куда меньшим индивидуальным эффектом. Увеличивать число «генов» или сильно уменьшать вклад каждого в этой демке невыгодно: модель стала бы тяжелее, а изменения длины шеи было бы хуже видно «на глаз».</li>
          <li>Тем не менее, она иллюстрирует несколько ключевых идей:
            <ul>
              <li>как стабилизирующий отбор формирует <strong>колоколообразное распределение</strong> признака;</li>
              <li>почему даже при отборе в популяции неизбежно остаются и «минусующие», и «плюсующие» аллели;</li>
              <li>как меняются частоты генов (тепловая карта) и генотипы отдельных особей (список геномов) по мере эволюции.</li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </details>

  <div class="controls">
    <button id="toggleBtn">Старт</button>
    <button id="stepBtn">1 шаг</button>
    <button id="resetBtn">Сбросить</button>
    <label class="mut-label">
      Признак:
      <select id="traitModeSelect">
        <option value="polygenic" selected>Полигенный</option>
        <option value="monogenic">Моногенный</option>
      </select>
    </label>
    <label class="mut-label">
      Мутаций на поколение:
      <select id="mutRateSelect">
        <option value="0">0</option>
        <option value="1">1</option>
        <option value="10">10</option>
        <option value="100" selected>100</option>
        <option value="1000">1000</option>
      </select>
    </label>
    <label class="slider-label">
      Давление отбора (σ):
      <input type="range" id="sigmaSlider" min="10" max="500" step="10" value="310" style="width: 180px;" />
      <span class="slider-value" id="sigmaValue">200</span>
    </label>
  </div>

  <div class="stats">
    Поколение:
    <span class="value" id="genSpan" style="width: 4ch">0</span>
    &nbsp;|&nbsp; средняя длина шеи:
    <span class="value" id="meanSpan" style="width: 4ch">0</span> см
    &nbsp;|&nbsp; мин:
    <span class="value" id="minSpan" style="width: 4ch">0</span> см
    &nbsp;|&nbsp; макс:
    <span class="value" id="maxSpan" style="width: 4ch">0</span> см
    &nbsp;|&nbsp; SD:
    <span class="value" id="sdSpan" style="width: 4ch">0</span> см
  </div>

  <div class="charts-layout">
    <div class="charts-column">
      <div class="card">
        <div class="card-title">Распределение длины шеи в текущем поколении</div>
        <div class="canvas-frame intrinsic-size">
          <canvas id="histCanvas" width="640" height="200"></canvas>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Динамика средней длины шеи</div>
        <div class="canvas-frame intrinsic-size">
          <canvas id="timeCanvas" width="640" height="200"></canvas>
        </div>
        <div class="note">
          Линия — средняя длина шеи по поколениям. Пунктир — оптимум 150&nbsp;см.
        </div>
      </div>

      <div class="card genome-card">
        <div class="card-title">Топ-5 длинных и 5 коротких особей</div>
        <div class="genome-list" id="topGenomes">Загружаем данные...</div>
      </div>
    </div>

    <div class="card allele-card">
      <div class="card-title">Распределение аллелей</div>
      <div class="canvas-frame intrinsic-size">
        <canvas id="alleleCanvas" class="allele-canvas" width="220" height="520" tabindex="0" aria-label="Распределение аллелей"></canvas>
      </div>
      <div class="note">Каждая строка — позиция генома; цвета показывают доли A/C/G/T в популяции. Кликните на строку, чтобы увидеть подробности.</div>
      <div class="allele-info" id="alleleInfo">Загружаем данные...</div>
    </div>
  </div>
</div>
<div class="footer" style="margin-top: 0;">
  © autism_science • MIT License •
  <a href="https://github.com/yupic/science-demos" target="_blank" rel="noopener">GitHub</a> •
  <a href="https://www.youtube.com/@autism-ru" target="_blank" rel="noopener">YouTube</a> •
  <a href="https://t.me/autism_science" target="_blank" rel="noopener">Telegram</a>
</div>

<script>
(() => {
  // --- ПАРАМЕТРЫ МОДЕЛИ ---
  const POP_SIZE = 10000;
  const GENOME_LENGTH = 100; // 100 букв A/T/G/C
  const LETTERS = ['A', 'C', 'G', 'T'];
  const LETTER_INDEX = { A: 0, C: 1, G: 2, T: 3 };
  const ALLELE_COLORS = {
    A: '#e74c3c',
    C: '#f1c40f',
    G: '#2980b9',
    T: '#27ae60'
  };

  const BASE_NECK = 50;        // базовая длина
  const OPTIMAL_NECK = 150;    // оптимум стабилизирующего отбора
  const NECK_MIN_AXIS = 0;     // ось графиков по Y
  const NECK_MAX_AXIS = 200;

  const HIST_BINS = NECK_MAX_AXIS;
  const STEP_INTERVAL_MS = 0;   // минимальный интервал между шагами, симуляция на максимальной скорости
  const ALLELE_LINE_THICKNESS = 5; // px
  const ALLELE_LINE_LENGTH = 200;  // px
  const ALLELE_MARKER_SIZE = ALLELE_LINE_THICKNESS;
  const ALLELE_MARKER_OFFSET = ALLELE_LINE_THICKNESS;
  const ALLELE_MARKER_COLOR = '#8e44ad';
  const TOP_LONG_GENOMES = 5;
  const TOP_SHORT_GENOMES = 5;

  const TRAIT_MODES = {
    POLYGENIC: 'polygenic',
    MONOGENIC: 'monogenic'
  };

  // --- СОСТОЯНИЕ ---
  let effectMap = [];          // [позиция][буква] -> вклад в см (−5..5)
  let allowedInitial = [];     // [позиция] -> Set(букв), доступных в начальной популяции
  let population = [];         // [{ genome: string, neck: number }]
  let generation = 0;
  let history = [];            // [{ gen, mean, min, max }]
  let isRunning = false;
  let intervalId = null;

  let globalOffset = 0;        // ожидаемый суммарный вклад генов для случайного генома
  let mutationRate = 10;       // ожидаемое число мутаций на поколение
  let selectionSigma = 200;    // давление отбора
  const stepIntervalMs = STEP_INTERVAL_MS;
  let selectedAllelePos = 0;
  let lastAlleleFreqs = [];
  let traitMode = TRAIT_MODES.POLYGENIC;

  // --- ВСПОМОГАТЕЛЬНОЕ ---
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function randomEffect() {
    // большинство эффектов около 0, редкие крупные
    const base = Math.round((Math.random() * 2 - 1) * 2); // -2..2
    if (Math.random() < 0.1) { // редкие большие
      return base * 2; // -4..4
    }
    return base;
  }

  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = randInt(0, i);
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // --- ИНИЦИАЛИЗАЦИЯ ГЕНЕТИКИ ---
  function initGenetics() {
    effectMap = new Array(GENOME_LENGTH);
    allowedInitial = new Array(GENOME_LENGTH);
    globalOffset = 0;

    for (let pos = 0; pos < GENOME_LENGTH; pos++) {
      const posMap = {};

      if (traitMode === TRAIT_MODES.MONOGENIC) {
        posMap['A'] = 0;
        const mutantLetters = LETTERS.filter(letter => letter !== 'A');
        const effects = mutantLetters.map(() => randInt(-2, 2));
        const sorted = effects.slice().sort((a, b) => a - b);
        mutantLetters.forEach((letter, idx) => {
          posMap[letter] = sorted[idx];
        });
        allowedInitial[pos] = new Set(['A']);
      } else {
        const effects = LETTERS.map(() => randInt(-2, 2));
        const sorted = effects.slice().sort((a, b) => a - b);
        LETTERS.forEach((letter, idx) => {
          posMap[letter] = sorted[idx];
        });
        const shuffledLetters = shuffle(LETTERS.slice());
        // для каждой позиции выбираем ровно 2 стартовых аллеля
        allowedInitial[pos] = new Set([shuffledLetters[0], shuffledLetters[1]]);
      }

      effectMap[pos] = posMap;
    }

    globalOffset = 0;
    for (let pos = 0; pos < GENOME_LENGTH; pos++) {
      let sum = 0;
      let count = 0;
      allowedInitial[pos].forEach(letter => {
        sum += effectMap[pos][letter];
        count++;
      });
      const meanAtPos = sum / count;
      globalOffset += meanAtPos;
    }
  }

  function randomInitialGenome() {
    const chars = [];
    for (let pos = 0; pos < GENOME_LENGTH; pos++) {
      const allowed = Array.from(allowedInitial[pos]);
      const chosen = allowed[randInt(0, allowed.length - 1)];
      chars.push(chosen);
    }
    return chars.join('');
  }

  function computeNeck(genome) {
    let sum = 0;
    for (let i = 0; i < GENOME_LENGTH; i++) {
      const letter = genome[i];
      sum += effectMap[i][letter];
    }
    return BASE_NECK + (sum - globalOffset);
  }

  function createIndividual(genome) {
    const neck = computeNeck(genome);
    return { genome, neck };
  }

  function computeFitness(neck) {
    const diff = neck - OPTIMAL_NECK;
    const sigma = selectionSigma; // чем больше sigma, тем слабее отбор
    return Math.exp(-0.5 * (diff * diff) / (sigma * sigma));
  }

  function recombineGenomes(g1, g2) {
    const len = g1.length;
    const child = new Array(len);
    let i = 0;

    while (i < len) {
      let bits = (Math.random() * 0x100000000) >>> 0;

      for (let k = 0; k < 32 && i < len; k++, i++) {
        child[i] = (bits & 1) ? g1[i] : g2[i];
        bits >>>= 1;
      }
    }

    return child.join('');
  }

  function chooseParentIndex(cumFitness) {
    const total = cumFitness[cumFitness.length - 1];
    let r = Math.random() * total;
    let lo = 0;
    let hi = cumFitness.length - 1;
    while (lo < hi) {
      const mid = (lo + hi) >> 1;
      if (r <= cumFitness[mid]) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return lo;
  }

  function applyMutations(pop) {
    const n = pop.length;
    let lambda = Math.max(0, mutationRate);
    const full = Math.floor(lambda);
    const frac = lambda - full;

    let totalMut = full;
    if (Math.random() < frac) totalMut++;

    for (let k = 0; k < totalMut; k++) {
      const mutChildIdx = randInt(0, n - 1);
      const mutPos = randInt(0, GENOME_LENGTH - 1);
      let gChars = pop[mutChildIdx].genome.split('');
      const oldBase = gChars[mutPos];
      let newBase = oldBase;
      while (newBase === oldBase) {
        newBase = LETTERS[randInt(0, LETTERS.length - 1)];
      }
      gChars[mutPos] = newBase;
      const newGenome = gChars.join('');
      pop[mutChildIdx].genome = newGenome;
      pop[mutChildIdx].neck = computeNeck(newGenome);
    }
  }

  function makeNextGeneration(pop) {
    const n = pop.length;
    const cumFitness = new Array(n);
    let sumFit = 0;
    for (let i = 0; i < n; i++) {
      const f = computeFitness(pop[i].neck);
      sumFit += f;
      cumFitness[i] = sumFit;
    }

    const newPop = new Array(n);
    for (let i = 0; i < n; i++) {
      const momIdx = chooseParentIndex(cumFitness);
      const dadIdx = chooseParentIndex(cumFitness);
      const mother = pop[momIdx];
      const father = pop[dadIdx];
      const genome = recombineGenomes(mother.genome, father.genome);
      newPop[i] = createIndividual(genome);
    }

    // применяем случайное число мутаций в этом поколении
    applyMutations(newPop);
    return newPop;
  }

  function computeStats(pop) {
    let mean = 0;
    let m2 = 0;
    let min = Infinity;
    let max = -Infinity;
    let count = 0;
    for (const { neck } of pop) {
      count += 1;
      if (neck < min) min = neck;
      if (neck > max) max = neck;
      const delta = neck - mean;
      mean += delta / count;
      const delta2 = neck - mean;
      m2 += delta * delta2;
    }
    const variance = m2 / count;
    const sd = Math.sqrt(variance);
    return {
      mean,
      min,
      max,
      sd
    };
  }

  function recordStats() {
    const s = computeStats(population);
    history.push({
      gen: generation,
      mean: s.mean,
      min: s.min,
      max: s.max,
      sd: s.sd
    });
  }

  // --- РИСОВАНИЕ: ГИСТОГРАММА ---
  const histCanvas = document.getElementById('histCanvas');
  const histCtx = histCanvas.getContext('2d');

  function drawHistogram(pop) {
    const ctx = histCtx;
    const rect = histCanvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    ctx.clearRect(0, 0, w, h);

    const margin = { left: 20, right: 20, top: 10, bottom: 20 };
    const plotW = w - margin.left - margin.right;
    const plotH = h - margin.top - margin.bottom;

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(margin.left, margin.top, plotW, plotH);

    const minX = NECK_MIN_AXIS;
    const maxX = NECK_MAX_AXIS;
    const binCount = HIST_BINS;
    const binSize = (maxX - minX) / binCount;
    const bins = new Array(binCount).fill(0);

    for (const ind of pop) {
      let v = ind.neck;
      if (v < minX) v = minX;
      if (v > maxX) v = maxX - 1e-6;
      const idx = Math.floor((v - minX) / binSize);
      bins[idx]++;
    }

    const maxBin = Math.max(...bins, 1);

    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    const gridYSteps = 4;
    for (let i = 0; i <= gridYSteps; i++) {
      const y = margin.top + (plotH * i) / gridYSteps;
      ctx.beginPath();
      ctx.moveTo(margin.left, y);
      ctx.lineTo(margin.left + plotW, y);
      ctx.stroke();
    }

    const barWidth = plotW / binCount;
    const rectWidth = barWidth - (barWidth >= 2 ? 1 : 0);
    ctx.fillStyle = '#2c7be5';
    for (let i = 0; i < binCount; i++) {
      const count = bins[i];
      const barHeight = (count / maxBin) * plotH;
      const x = margin.left + i * barWidth;
      const y = margin.top + plotH - barHeight;
      ctx.fillRect(x, y, rectWidth, barHeight);
    }

    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top + plotH);
    ctx.lineTo(margin.left + plotW, margin.top + plotH);
    ctx.stroke();

    ctx.fillStyle = '#333';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const ticks = 4;
    for (let i = 0; i <= ticks; i++) {
      const v = minX + ((maxX - minX) * i) / ticks;
      const x = margin.left + (plotW * i) / ticks;
      const y = margin.top + plotH + 4;
      ctx.fillText(Math.round(v), x, y);
    }
    ctx.textAlign = 'left';
    ctx.fillText('Длина шеи, см', margin.left + 30, margin.top + plotH + 4 /*h - 30*/);
  }

  // --- РИСОВАНИЕ: ВРЕМЯ ---
  const timeCanvas = document.getElementById('timeCanvas');
  const timeCtx = timeCanvas.getContext('2d');

  function drawTimeSeries() {
    const ctx = timeCtx;
    const rect = timeCanvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    ctx.clearRect(0, 0, w, h);

    if (history.length === 0) return;

    const margin = { left: 20, right: 20, top: 0, bottom: 20 };
    const plotW = w - margin.left - margin.right;
    const plotH = h - margin.top - margin.bottom;

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(margin.left, margin.top, plotW, plotH);

    const minY = NECK_MIN_AXIS;
    const maxY = NECK_MAX_AXIS;

    const lastGen = history[history.length - 1].gen;
    // ДО 1000 поколений шкала фиксирована 0..1000, дальше тянется за линией
    const maxGen = Math.max(1000, lastGen);

    // Сетка по Y
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    const gridYSteps = 4;
    for (let i = 0; i <= gridYSteps; i++) {
      const y = margin.top + (plotH * i) / gridYSteps;
      ctx.beginPath();
      ctx.moveTo(margin.left, y);
      ctx.lineTo(margin.left + plotW, y);
      ctx.stroke();
    }

    // Линия оптимума
    const optY = margin.top + plotH - ((OPTIMAL_NECK - minY) / (maxY - minY)) * plotH;
    ctx.save();
    ctx.strokeStyle = '#999';
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(margin.left, optY);
    ctx.lineTo(margin.left + plotW, optY);
    ctx.stroke();
    ctx.restore();

    // Линия средней длины
    ctx.strokeStyle = '#e67e22';
    ctx.lineWidth = 2;
    ctx.beginPath();
    history.forEach((pt, idx) => {
      const x = margin.left + (plotW * pt.gen) / maxGen;
      const y = margin.top + plotH - ((pt.mean - minY) / (maxY - minY)) * plotH;
      if (idx === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // ВЫДЕЛЯЕМ ПОСЛЕДНЮЮ ТОЧКУ
    const last = history[history.length - 1];
    const lastX = margin.left + (plotW * last.gen) / maxGen;
    const lastY = margin.top + plotH - ((last.mean - minY) / (maxY - minY)) * plotH;
    ctx.beginPath();
    ctx.fillStyle = '#e67e22';
    ctx.arc(lastX, lastY, 4, 0, Math.PI * 2); // кружок толще линии
    ctx.fill();

    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(last.mean.toFixed(1), lastX, lastY - 20);

    // Ось X (поколения)
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top + plotH);
    ctx.lineTo(margin.left + plotW, margin.top + plotH);
    ctx.stroke();

    ctx.fillStyle = '#333';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const ticks = 4;
    for (let i = 0; i <= ticks; i++) {
      const g = Math.round((maxGen * i) / ticks);
      const x = margin.left + (plotW * i) / ticks;
      const y = margin.top + plotH + 4;
      ctx.fillText(g, x, y);
    }

    ctx.textAlign = 'left';
    ctx.fillText('Поколение', margin.left + 30, margin.top + plotH + 4 /*h - 20*/);
  }

  // --- РИСОВАНИЕ: АЛЛЕЛИ ---
  const alleleCanvas = document.getElementById('alleleCanvas');
  const alleleCtx = alleleCanvas.getContext('2d');
  const ALLELE_MARGIN = 10;

  function ensureAlleleCanvasSize() {
    const width = ALLELE_MARGIN * 2 + ALLELE_LINE_LENGTH;
    const height = ALLELE_MARGIN * 2 + GENOME_LENGTH * ALLELE_LINE_THICKNESS;
    const ratio = window.devicePixelRatio || 1;
    alleleCanvas.width = Math.round(width * ratio);
    alleleCanvas.height = Math.round(height * ratio);
    alleleCanvas.style.width = `${width}px`;
    alleleCanvas.style.height = `${height}px`;
    alleleCtx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }

  function computeAlleleFrequencies(pop) {
    const total = pop.length;
    if (!total) return [];

    const genomeLen = GENOME_LENGTH;
    const counts = Array.from({ length: genomeLen }, () => [0, 0, 0, 0]);

    for (let p = 0; p < total; p++) {
      const genome = pop[p].genome;
      for (let i = 0; i < genomeLen; i++) {
        counts[i][LETTER_INDEX[genome[i]]]++;
      }
    }

    const scale = 100 / total;
    const result = new Array(genomeLen);

    for (let i = 0; i < genomeLen; i++) {
      const c = counts[i];
      result[i] = {
        A: c[0] * scale,
        C: c[1] * scale,
        G: c[2] * scale,
        T: c[3] * scale,
      };
    }

    return result;
  }

  function drawAlleleFrequencies(pop) {
    const freqs = computeAlleleFrequencies(pop);
    lastAlleleFreqs = freqs;
    alleleCtx.clearRect(0, 0, alleleCanvas.width, alleleCanvas.height);
    let y = ALLELE_MARGIN;
    for (let pos = 0; pos < freqs.length; pos++) {
      let x = ALLELE_MARGIN;
      LETTERS.forEach(letter => {
        const seg = (freqs[pos][letter] / 100) * ALLELE_LINE_LENGTH;
        alleleCtx.fillStyle = ALLELE_COLORS[letter];
        alleleCtx.fillRect(x, y, seg, ALLELE_LINE_THICKNESS);
        x += seg;
      });
      y += ALLELE_LINE_THICKNESS;
    }

    if (selectedAllelePos >= 0 && selectedAllelePos < GENOME_LENGTH) {
      const markerY = ALLELE_MARGIN + selectedAllelePos * ALLELE_LINE_THICKNESS;
      alleleCtx.fillStyle = ALLELE_MARKER_COLOR;
      const leftX = ALLELE_MARGIN - ALLELE_MARKER_OFFSET - ALLELE_MARKER_SIZE;
      const rightX = ALLELE_MARGIN + ALLELE_LINE_LENGTH + ALLELE_MARKER_OFFSET;
      alleleCtx.fillRect(leftX, markerY, ALLELE_MARKER_SIZE, ALLELE_MARKER_SIZE);
      alleleCtx.fillRect(rightX, markerY, ALLELE_MARKER_SIZE, ALLELE_MARKER_SIZE);
    }

    alleleCtx.lineWidth = 1;
    alleleCtx.strokeStyle = '#ccc';
    alleleCtx.strokeRect(ALLELE_MARGIN - 0.5, ALLELE_MARGIN - 0.5, ALLELE_LINE_LENGTH + 1, GENOME_LENGTH * ALLELE_LINE_THICKNESS + 1);
    return freqs;
  }

  // --- UI ОБНОВЛЕНИЕ ---
  const genSpan = document.getElementById('genSpan');
  const meanSpan = document.getElementById('meanSpan');
  const minSpan = document.getElementById('minSpan');
  const maxSpan = document.getElementById('maxSpan');
  const sdSpan = document.getElementById('sdSpan');
  const toggleBtn = document.getElementById('toggleBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const traitModeSelect = document.getElementById('traitModeSelect');
  const mutRateSelect = document.getElementById('mutRateSelect');
  const sigmaSlider = document.getElementById('sigmaSlider');
  const sigmaValue = document.getElementById('sigmaValue');
  const alleleInfo = document.getElementById('alleleInfo');
  const topGenomes = document.getElementById('topGenomes');
  let alleleInfoReady = false;
  let alleleInfoTitle = null;
  let alleleInfoPlaceholder = null;
  let alleleInfoContent = null;
  const alleleInfoValues = {};

  const clampAllelePos = (pos) => Math.min(Math.max(pos, 0), GENOME_LENGTH - 1);

  const sliderValueToSigma = (value) => 510 - value;

  function selectAllele(pos) {
    selectedAllelePos = clampAllelePos(pos);
    drawAlleleFrequencies(population);
    showAlleleInfo(selectedAllelePos);
  }

  function ensureAlleleInfoElements() {
    if (alleleInfoReady) return;

    alleleInfo.innerHTML = '';

    alleleInfoPlaceholder = document.createElement('div');
    alleleInfoPlaceholder.className = 'allele-info-placeholder';
    alleleInfoPlaceholder.textContent = 'Загружаем данные...';
    alleleInfo.appendChild(alleleInfoPlaceholder);

    alleleInfoContent = document.createElement('div');
    alleleInfoContent.className = 'allele-info-content';
    alleleInfo.appendChild(alleleInfoContent);

    alleleInfoTitle = document.createElement('div');
    alleleInfoTitle.className = 'allele-info-title';
    alleleInfoContent.appendChild(alleleInfoTitle);

    LETTERS.forEach(letter => {
      const row = document.createElement('div');
      row.className = 'allele-info-row';

      const swatch = document.createElement('div');
      swatch.className = 'allele-legend-swatch';
      swatch.style.background = ALLELE_COLORS[letter];

      const text = document.createElement('div');
      alleleInfoValues[letter] = text;

      row.appendChild(swatch);
      row.appendChild(text);
      alleleInfoContent.appendChild(row);
    });

    alleleInfoReady = true;
  }

  function showAlleleInfo(pos) {
    ensureAlleleInfoElements();

    if (!lastAlleleFreqs || lastAlleleFreqs.length === 0) {
      alleleInfoPlaceholder.textContent = 'Нажмите на строку, чтобы увидеть вклад букв для позиции.';
      alleleInfoPlaceholder.style.display = 'block';
      alleleInfoContent.style.display = 'none';
      return;
    }

    alleleInfoPlaceholder.style.display = 'none';
    alleleInfoContent.style.display = 'block';

    if (pos < 0 || pos >= GENOME_LENGTH) {
      pos = selectedAllelePos;
    }
    selectedAllelePos = pos;

    const effects = effectMap[pos];
    const freqs = lastAlleleFreqs[pos];
    alleleInfoTitle.textContent = `Позиция ${pos}`;

    LETTERS.forEach(letter => {
      const effectVal = effects[letter];
      const freqVal = freqs ? freqs[letter] : 0;
      alleleInfoValues[letter].textContent = `${letter}: ${effectVal >= 0 ? '+' : ''}${effectVal} см, ${freqVal.toFixed(1)}%`;
    });
  }

  function updateSigmaFromSlider() {
    const v = parseFloat(sigmaSlider.value);
    selectionSigma = sliderValueToSigma(!Number.isNaN(v) ? v : 810);
    sigmaValue.textContent = selectionSigma.toFixed(0);
  }

  function updateMutationFromSelect() {
    const v = parseFloat(mutRateSelect.value);
    if (!Number.isNaN(v) && v >= 0) {
      mutationRate = v;
    }
  }

  function updateStatsUI() {
    const last = history[history.length - 1];
    genSpan.textContent = last.gen;
    meanSpan.textContent = last.mean.toFixed(1);
    minSpan.textContent = last.min.toFixed(1);
    maxSpan.textContent = last.max.toFixed(1);
    sdSpan.textContent = last.sd.toFixed(2);
  }

  function colorizeGenome(genome) {
    return genome
      .split('')
      .map((letter, idx) =>
        `<span class="genome-letter-${letter}" data-pos="${idx}" style="background-color:${ALLELE_COLORS[letter] || 'inherit'}; cursor: pointer;">${letter}</span>`
      )
      .join('');
  }

  function renderTopGenomes(pop) {
    if (!pop || pop.length === 0) {
      topGenomes.textContent = 'Нет данных';
      return;
    }

    const indexed = pop
      .map((ind, idx) => ({ ...ind, index: idx }))
      .sort((a, b) => {
        if (b.neck !== a.neck) return b.neck - a.neck;
        const genomeCmp = a.genome.localeCompare(b.genome);
        if (genomeCmp !== 0) return genomeCmp;
        return a.index - b.index;
      });

    const topLongest = indexed.slice(0, TOP_LONG_GENOMES);
    const shortestCandidates = indexed.slice(-TOP_SHORT_GENOMES);
    const seen = new Set(topLongest.map(ind => ind.index));
    const topShortest = shortestCandidates.filter(ind => {
      if (seen.has(ind.index)) return false;
      seen.add(ind.index);
      return true;
    });

    const combined = topLongest.concat(topShortest);

    const frag = document.createDocumentFragment();
    combined.forEach(ind => {
      const row = document.createElement('div');
      row.className = 'genome-row';
      row.style.display = 'flex';
      row.style.alignItems = 'center';

      const genomeSpan = document.createElement('div');
      genomeSpan.className = 'genome-letter-row';
      genomeSpan.style.whiteSpace = 'pre';
      genomeSpan.innerHTML = colorizeGenome(ind.genome);
      genomeSpan.addEventListener('click', (evt) => {
        const target = evt.target;
        const pos = Number.parseInt(target.dataset?.pos, 10);
        if (!Number.isNaN(pos)) {
          selectAllele(pos);
          alleleCanvas.focus({ preventScroll: true });
        }
      });
      row.appendChild(genomeSpan);

      const suffix = document.createElement('div');
      suffix.textContent = ` ${ind.neck.toFixed(0)} см`;
      suffix.style.whiteSpace = 'pre';
      suffix.style.minWidth = '7ch';
      row.appendChild(suffix);

      frag.appendChild(row);
    });

    topGenomes.replaceChildren(frag);
  }

  function updateUI() {
    drawHistogram(population);
    drawTimeSeries();
    drawAlleleFrequencies(population);
    updateStatsUI();
    showAlleleInfo(selectedAllelePos);
    renderTopGenomes(population);
  }

  // --- СИМУЛЯЦИЯ ---
  function initSimulation() {
    isRunning = false;
    if (intervalId !== null) {
      clearInterval(intervalId);
      intervalId = null;
    }
    traitModeSelect.disabled = false;
    generation = 0;
    history = [];
    selectedAllelePos = 0;
    lastAlleleFreqs = [];
    traitMode = traitModeSelect.value === TRAIT_MODES.MONOGENIC ? TRAIT_MODES.MONOGENIC : TRAIT_MODES.POLYGENIC;
    initGenetics();

    updateMutationFromSelect();
    updateSigmaFromSlider();

    population = new Array(POP_SIZE);
    for (let i = 0; i < POP_SIZE; i++) {
      const genome = randomInitialGenome();
      population[i] = createIndividual(genome);
    }
    recordStats();
    updateUI();
    toggleBtn.textContent = 'Старт';
  }

  function stepSimulation() {
    population = makeNextGeneration(population);
    generation++;
    recordStats();
    updateUI();
  }

  function startSimulation() {
    if (isRunning) return;
    isRunning = true;
    toggleBtn.textContent = 'Пауза';
    traitModeSelect.disabled = true;
    intervalId = setInterval(stepSimulation, stepIntervalMs);
  }

  function stopSimulation() {
    if (!isRunning) return;
    isRunning = false;
    toggleBtn.textContent = 'Старт';
    traitModeSelect.disabled = false;
    if (intervalId !== null) {
      clearInterval(intervalId);
      intervalId = null;
    }
  }

  // --- ОБРАБОТЧИКИ ---
  toggleBtn.addEventListener('click', () => {
    if (isRunning) stopSimulation();
    else startSimulation();
  });

  stepBtn.addEventListener('click', () => {
    if (!isRunning) {
      stepSimulation();
    }
  });

  resetBtn.addEventListener('click', () => {
    initSimulation();
  });

  traitModeSelect.addEventListener('change', () => {
    traitMode = traitModeSelect.value === TRAIT_MODES.MONOGENIC ? TRAIT_MODES.MONOGENIC : TRAIT_MODES.POLYGENIC;
    initSimulation();
  });

  mutRateSelect.addEventListener('change', updateMutationFromSelect);
  sigmaSlider.addEventListener('input', updateSigmaFromSlider);

  alleleCanvas.addEventListener('click', (evt) => {
    const rect = alleleCanvas.getBoundingClientRect();
    const scaleY = alleleCanvas.height / rect.height;
    const y = (evt.clientY - rect.top) * scaleY;
    const pos = Math.floor((y - ALLELE_MARGIN) / ALLELE_LINE_THICKNESS);
    if (pos >= 0 && pos < GENOME_LENGTH) {
      selectAllele(pos);
      alleleCanvas.focus({ preventScroll: true });
    } else {
      showAlleleInfo(-1);
    }
  });

  alleleCanvas.addEventListener('keydown', (evt) => {
    if (evt.key === 'ArrowUp' || evt.key === 'ArrowDown') {
      evt.preventDefault();
      const delta = evt.key === 'ArrowUp' ? -1 : 1;
      selectAllele(selectedAllelePos + delta);
    }
  });

  function resizeCanvases() {
    [histCanvas, timeCanvas].forEach(canvas => {
      const rect = canvas.getBoundingClientRect();
      const cssWidth = canvas.clientWidth || rect.width;
      const cssHeight = canvas.clientHeight || rect.height;
      if (rect.width > 0) {
        const ratio = window.devicePixelRatio || 1;
        canvas.style.width = `${cssWidth}px`;
        canvas.style.height = `${cssHeight}px`;
        canvas.width = Math.round(rect.width * ratio);
        canvas.height = Math.round(rect.height * ratio);
        const ctx = canvas.getContext('2d');
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      }
    });
    ensureAlleleCanvasSize();
    updateUI();
  }
  window.addEventListener('resize', resizeCanvases);

  // Старт
  showAlleleInfo(-1);
  initSimulation();
  resizeCanvases();
})();
</script>
</body>
</html>
