<!--
Interactive science demo.
Part of the "science-demos" project.

GitHub: https://github.com/yupic/science-demos
YouTube: https://www.youtube.com/@autism-ru
Telegram: https://t.me/autism_science
License: MIT
-->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Эволюция длины шеи жирафа</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f5f5f5;
      --fg: #222;
      --accent: #2c7be5;
      --accent2: #e67e22;
      --muted: #666;
      --card: #fff;
      --border: #ddd;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--fg);
    }
    .container {
      margin: 0 auto;
      padding: 16px;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 24px;
    }
    p.desc {
      margin: 0 0 16px;
      color: var(--muted);
      font-size: 14px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
      align-items: center;
    }
    button {
      border: 1px solid var(--border);
      background: var(--card);
      border-radius: 6px;
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    button:hover {
      background: #f0f4ff;
    }
    button:active {
      transform: translateY(1px);
      box-shadow: 0 0 0 rgba(0,0,0,0.05);
    }
    .stats {
      font-size: 14px;
      color: var(--muted);
      margin-bottom: 12px;
    }
    .stats span.value {
      color: var(--fg);
      font-weight: 600;
    }
    .card {
      background: var(--card);
      border-radius: 8px;
      padding: 12px;
      border: 1px solid var(--border);
      margin-bottom: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.03);
    }
    .card-title {
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 6px;
    }
    canvas {
      display: block;
      width: auto;
      max-width: 100%;
      background: #fff;
    }
    .canvas-frame {
      border: 1px solid var(--border);
      border-radius: 4px;
      background: #fff;
      overflow: hidden;
    }
    .note {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }
    .mut-label, .slider-label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 13px;
    }
    .mut-label input, .mut-label select {
      padding: 4px 6px;
      font-size: 13px;
    }
    .slider-label input[type="range"] {
      width: 180px;
    }
    .slider-value {
      min-width: 42px;
      display: inline-block;
      text-align: left;
      color: var(--muted);
    }
    .charts-layout {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    .charts-column {
      flex: 0 0 auto;
      width: fit-content;
      max-width: 100%;
    }
    .allele-card {
      width: 240px;
      flex-shrink: 0;
    }
    .allele-canvas {
      display: block;
    }
    .allele-legend-swatch {
      width: 14px;
      height: 14px;
      border: 1px solid var(--border);
      border-radius: 3px;
      flex-shrink: 0;
    }
    .allele-info {
      margin-top: 8px;
      font-size: 13px;
      color: var(--fg);
      line-height: 1.4;
    }
    .allele-info-title {
      font-weight: 600;
      margin-bottom: 6px;
    }
    .allele-info-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      color: var(--muted);
    }
    .allele-info-row:last-child {
      margin-bottom: 0;
    }
    @media (max-width: 600px) {
      h1 { font-size: 20px; }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Эволюция длины шеи жирафа</h1>
  <p class="desc">
    Модель: 100 генов (A/T/G/C), каждый даёт вклад от −2 до +2 см. Отбор стабилизирующий вокруг 150&nbsp;см.
    На каждом поколении происходит в среднем заданное число мутаций (может быть меньше или больше за счёт случайности).
  </p>

  <div class="controls">
    <button id="toggleBtn">Старт</button>
    <button id="stepBtn">Шаг (1 поколение)</button>
    <button id="resetBtn">Сбросить</button>
    <label class="mut-label">
      Признак:
      <select id="traitModeSelect">
        <option value="polygenic" selected>Полигенный</option>
        <option value="monogenic">Моногенный</option>
      </select>
    </label>
    <label class="mut-label">
      Мутации/поколение:
      <select id="mutRateSelect">
        <option value="1">1</option>
        <option value="10">10</option>
        <option value="100" selected>100</option>
        <option value="1000">1000</option>
      </select>
    </label>
    <label class="slider-label">
      Давление отбора (σ):
      <input type="range" id="sigmaSlider" min="10" max="500" step="10" value="310" />
      <span class="slider-value" id="sigmaValue">200</span>
    </label>
    <label class="slider-label">
      Скорость (мс/шаг):
      <input type="range" id="speedSlider" min="0" max="5" step="1" value="0" />
      <span class="slider-value" id="speedValue">150</span>
    </label>
  </div>

  <div class="stats">
    Поколение:
    <span class="value" id="genSpan">0</span>
    &nbsp;|&nbsp; средняя длина шеи:
    <span class="value" id="meanSpan">0</span> см
    &nbsp;|&nbsp; мин:
    <span class="value" id="minSpan">0</span> см
    &nbsp;|&nbsp; макс:
    <span class="value" id="maxSpan">0</span> см
    &nbsp;|&nbsp; наблюдаемое SD:
    <span class="value" id="sdSpan">0</span> см
  </div>

  <div class="charts-layout">
    <div class="charts-column">
      <div class="card">
        <div class="card-title">Распределение длины шеи в текущем поколении</div>
        <div class="canvas-frame">
          <canvas id="histCanvas" width="640" height="260"></canvas>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Динамика средней длины шеи</div>
        <div class="canvas-frame">
          <canvas id="timeCanvas" width="640" height="220"></canvas>
        </div>
        <div class="note">
          Линия — средняя длина шеи по поколениям. Пунктир — оптимум 150&nbsp;см.
        </div>
      </div>
    </div>

    <div class="card allele-card">
      <div class="card-title">Распределение аллелей</div>
      <div class="canvas-frame">
        <canvas id="alleleCanvas" class="allele-canvas" width="220" height="520" tabindex="0" aria-label="Распределение аллелей"></canvas>
      </div>
      <div class="note">Каждая строка — позиция генома; цвета показывают доли A/C/G/T в популяции. Кликните на строку, чтобы увидеть подробности.</div>
      <div class="allele-info" id="alleleInfo">Загружаем данные...</div>
    </div>
  </div>
</div>

<script>
(() => {
  // --- ПАРАМЕТРЫ МОДЕЛИ ---
  const POP_SIZE = 10000;
  const GENOME_LENGTH = 100; // 100 букв A/T/G/C
  const LETTERS = ['A', 'C', 'G', 'T'];
  const ALLELE_COLORS = {
    A: '#e74c3c',
    C: '#f1c40f',
    G: '#2980b9',
    T: '#27ae60'
  };

  const BASE_NECK = 50;        // базовая длина
  const OPTIMAL_NECK = 150;    // оптимум стабилизирующего отбора
  const NECK_MIN_AXIS = 0;     // ось графиков по Y
  const NECK_MAX_AXIS = 200;

  const HIST_BINS = NECK_MAX_AXIS;
  const BASE_INTERVAL_MS = 150;
  const ALLELE_LINE_THICKNESS = 5; // px
  const ALLELE_LINE_LENGTH = 200;  // px
  const ALLELE_MARKER_SIZE = ALLELE_LINE_THICKNESS;
  const ALLELE_MARKER_OFFSET = ALLELE_LINE_THICKNESS;
  const ALLELE_MARKER_COLOR = '#8e44ad';

  const TRAIT_MODES = {
    POLYGENIC: 'polygenic',
    MONOGENIC: 'monogenic'
  };

  // --- СОСТОЯНИЕ ---
  let effectMap = [];          // [позиция][буква] -> вклад в см (−5..5)
  let allowedInitial = [];     // [позиция] -> Set(букв), доступных в начальной популяции
  let population = [];         // [{ genome: string, neck: number }]
  let generation = 0;
  let history = [];            // [{ gen, mean, min, max }]
  let isRunning = false;
  let intervalId = null;

  let globalOffset = 0;        // ожидаемый суммарный вклад генов для случайного генома
  let mutationRate = 10;       // ожидаемое число мутаций на поколение
  let selectionSigma = 200;    // давление отбора
  let stepIntervalMs = BASE_INTERVAL_MS; // скорость симуляции
  let selectedAllelePos = 0;
  let lastAlleleFreqs = [];
  let traitMode = TRAIT_MODES.POLYGENIC;

  // --- ВСПОМОГАТЕЛЬНОЕ ---
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function randomEffect() {
    // большинство эффектов около 0, редкие крупные
    const base = Math.round((Math.random() * 2 - 1) * 2); // -2..2
    if (Math.random() < 0.1) { // редкие большие
      return base * 2; // -4..4
    }
    return base;
  }

  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = randInt(0, i);
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // --- ИНИЦИАЛИЗАЦИЯ ГЕНЕТИКИ ---
  function initGenetics() {
    effectMap = new Array(GENOME_LENGTH);
    allowedInitial = new Array(GENOME_LENGTH);
    globalOffset = 0;

    for (let pos = 0; pos < GENOME_LENGTH; pos++) {
      const posMap = {};

      if (traitMode === TRAIT_MODES.MONOGENIC) {
        posMap['A'] = 0;
        const mutantLetters = LETTERS.filter(letter => letter !== 'A');
        const effects = mutantLetters.map(() => randInt(-2, 2));
        const sorted = effects.slice().sort((a, b) => a - b);
        mutantLetters.forEach((letter, idx) => {
          posMap[letter] = sorted[idx];
        });
        allowedInitial[pos] = new Set(['A']);
      } else {
        const effects = LETTERS.map(() => randInt(-2, 2));
        const sorted = effects.slice().sort((a, b) => a - b);
        LETTERS.forEach((letter, idx) => {
          posMap[letter] = sorted[idx];
        });
        const shuffledLetters = shuffle(LETTERS.slice());
        // для каждой позиции выбираем ровно 2 стартовых аллеля
        allowedInitial[pos] = new Set([shuffledLetters[0], shuffledLetters[1]]);
      }

      effectMap[pos] = posMap;
    }

    globalOffset = 0;
    for (let pos = 0; pos < GENOME_LENGTH; pos++) {
      let sum = 0;
      let count = 0;
      allowedInitial[pos].forEach(letter => {
        sum += effectMap[pos][letter];
        count++;
      });
      const meanAtPos = sum / count;
      globalOffset += meanAtPos;
    }
  }

  function randomInitialGenome() {
    const chars = [];
    for (let pos = 0; pos < GENOME_LENGTH; pos++) {
      const allowed = Array.from(allowedInitial[pos]);
      const chosen = allowed[randInt(0, allowed.length - 1)];
      chars.push(chosen);
    }
    return chars.join('');
  }

  function computeNeck(genome) {
    let sum = 0;
    for (let i = 0; i < GENOME_LENGTH; i++) {
      const letter = genome[i];
      sum += effectMap[i][letter];
    }
    return BASE_NECK + (sum - globalOffset);
  }

  function computeFitness(neck) {
    const diff = neck - OPTIMAL_NECK;
    const sigma = selectionSigma; // чем больше sigma, тем слабее отбор
    return Math.exp(-0.5 * (diff * diff) / (sigma * sigma));
  }

  function recombineGenomes(g1, g2) {
    const childChars = new Array(GENOME_LENGTH);
    for (let i = 0; i < GENOME_LENGTH; i++) {
      childChars[i] = Math.random() < 0.5 ? g1[i] : g2[i];
    }
    return childChars.join('');
  }

  function chooseParentIndex(cumFitness) {
    const total = cumFitness[cumFitness.length - 1];
    let r = Math.random() * total;
    let lo = 0;
    let hi = cumFitness.length - 1;
    while (lo < hi) {
      const mid = (lo + hi) >> 1;
      if (r <= cumFitness[mid]) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return lo;
  }

  function applyMutations(pop) {
    const n = pop.length;
    let lambda = Math.max(0, mutationRate);
    const full = Math.floor(lambda);
    const frac = lambda - full;

    let totalMut = full;
    if (Math.random() < frac) totalMut++;

    for (let k = 0; k < totalMut; k++) {
      const mutChildIdx = randInt(0, n - 1);
      const mutPos = randInt(0, GENOME_LENGTH - 1);
      let gChars = pop[mutChildIdx].genome.split('');
      const oldBase = gChars[mutPos];
      let newBase = oldBase;
      while (newBase === oldBase) {
        newBase = LETTERS[randInt(0, LETTERS.length - 1)];
      }
      gChars[mutPos] = newBase;
      const newGenome = gChars.join('');
      pop[mutChildIdx].genome = newGenome;
      pop[mutChildIdx].neck = computeNeck(newGenome);
    }
  }

  function makeNextGeneration(pop) {
    const n = pop.length;
    const cumFitness = new Array(n);
    let sumFit = 0;
    for (let i = 0; i < n; i++) {
      const f = computeFitness(pop[i].neck);
      sumFit += f;
      cumFitness[i] = sumFit;
    }

    const newPop = new Array(n);
    for (let i = 0; i < n; i++) {
      const momIdx = chooseParentIndex(cumFitness);
      const dadIdx = chooseParentIndex(cumFitness);
      const mother = pop[momIdx];
      const father = pop[dadIdx];
      const genome = recombineGenomes(mother.genome, father.genome);
      const neck = computeNeck(genome);
      newPop[i] = { genome, neck };
    }

    // применяем случайное число мутаций в этом поколении
    applyMutations(newPop);
    return newPop;
  }

  function computeStats(pop) {
    let mean = 0;
    let m2 = 0;
    let min = Infinity;
    let max = -Infinity;
    let count = 0;
    for (const { neck } of pop) {
      count += 1;
      if (neck < min) min = neck;
      if (neck > max) max = neck;
      const delta = neck - mean;
      mean += delta / count;
      const delta2 = neck - mean;
      m2 += delta * delta2;
    }
    const variance = m2 / count;
    const sd = Math.sqrt(variance);
    return {
      mean,
      min,
      max,
      sd
    };
  }

  function recordStats() {
    const s = computeStats(population);
    history.push({
      gen: generation,
      mean: s.mean,
      min: s.min,
      max: s.max,
      sd: s.sd
    });
  }

  // --- РИСОВАНИЕ: ГИСТОГРАММА ---
  const histCanvas = document.getElementById('histCanvas');
  const histCtx = histCanvas.getContext('2d');

  function drawHistogram(pop) {
    const ctx = histCtx;
    const rect = histCanvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    ctx.clearRect(0, 0, w, h);

    const margin = { left: 20, right: 20, top: 10, bottom: 40 };
    const plotW = w - margin.left - margin.right;
    const plotH = h - margin.top - margin.bottom;

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(margin.left, margin.top, plotW, plotH);

    const minX = NECK_MIN_AXIS;
    const maxX = NECK_MAX_AXIS;
    const binCount = HIST_BINS;
    const binSize = (maxX - minX) / binCount;
    const bins = new Array(binCount).fill(0);

    for (const ind of pop) {
      let v = ind.neck;
      if (v < minX) v = minX;
      if (v > maxX) v = maxX - 1e-6;
      const idx = Math.floor((v - minX) / binSize);
      bins[idx]++;
    }

    const maxBin = Math.max(...bins, 1);

    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    const gridYSteps = 4;
    for (let i = 0; i <= gridYSteps; i++) {
      const y = margin.top + (plotH * i) / gridYSteps;
      ctx.beginPath();
      ctx.moveTo(margin.left, y);
      ctx.lineTo(margin.left + plotW, y);
      ctx.stroke();
    }

    const barWidth = plotW / binCount;
    const rectWidth = barWidth - (barWidth >= 2 ? 1 : 0);
    ctx.fillStyle = '#2c7be5';
    for (let i = 0; i < binCount; i++) {
      const count = bins[i];
      const barHeight = (count / maxBin) * plotH;
      const x = margin.left + i * barWidth;
      const y = margin.top + plotH - barHeight;
      ctx.fillRect(x, y, rectWidth, barHeight);
    }

    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top + plotH);
    ctx.lineTo(margin.left + plotW, margin.top + plotH);
    ctx.stroke();

    ctx.fillStyle = '#333';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const ticks = 4;
    for (let i = 0; i <= ticks; i++) {
      const v = minX + ((maxX - minX) * i) / ticks;
      const x = margin.left + (plotW * i) / ticks;
      const y = margin.top + plotH + 4;
      ctx.fillText(Math.round(v), x, y);
    }
    ctx.textAlign = 'left';
    ctx.fillText('Длина шеи, см', margin.left, h - 20);
  }

  // --- РИСОВАНИЕ: ВРЕМЯ ---
  const timeCanvas = document.getElementById('timeCanvas');
  const timeCtx = timeCanvas.getContext('2d');

  function drawTimeSeries() {
    const ctx = timeCtx;
    const rect = timeCanvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    ctx.clearRect(0, 0, w, h);

    if (history.length === 0) return;

    const margin = { left: 20, right: 20, top: 10, bottom: 40 };
    const plotW = w - margin.left - margin.right;
    const plotH = h - margin.top - margin.bottom;

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(margin.left, margin.top, plotW, plotH);

    const minY = NECK_MIN_AXIS;
    const maxY = NECK_MAX_AXIS;

    const lastGen = history[history.length - 1].gen;
    // ДО 1000 поколений шкала фиксирована 0..1000, дальше тянется за линией
    const maxGen = Math.max(1000, lastGen);

    // Сетка по Y
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    const gridYSteps = 4;
    for (let i = 0; i <= gridYSteps; i++) {
      const y = margin.top + (plotH * i) / gridYSteps;
      ctx.beginPath();
      ctx.moveTo(margin.left, y);
      ctx.lineTo(margin.left + plotW, y);
      ctx.stroke();
    }

    // Линия оптимума
    const optY = margin.top + plotH - ((OPTIMAL_NECK - minY) / (maxY - minY)) * plotH;
    ctx.save();
    ctx.strokeStyle = '#999';
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(margin.left, optY);
    ctx.lineTo(margin.left + plotW, optY);
    ctx.stroke();
    ctx.restore();

    // Линия средней длины
    ctx.strokeStyle = '#e67e22';
    ctx.lineWidth = 2;
    ctx.beginPath();
    history.forEach((pt, idx) => {
      const x = margin.left + (plotW * pt.gen) / maxGen;
      const y = margin.top + plotH - ((pt.mean - minY) / (maxY - minY)) * plotH;
      if (idx === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // ВЫДЕЛЯЕМ ПОСЛЕДНЮЮ ТОЧКУ
    const last = history[history.length - 1];
    const lastX = margin.left + (plotW * last.gen) / maxGen;
    const lastY = margin.top + plotH - ((last.mean - minY) / (maxY - minY)) * plotH;
    ctx.beginPath();
    ctx.fillStyle = '#e67e22';
    ctx.arc(lastX, lastY, 4, 0, Math.PI * 2); // кружок толще линии
    ctx.fill();

    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(last.mean.toFixed(1), lastX, lastY - 20);

    // Ось X (поколения)
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top + plotH);
    ctx.lineTo(margin.left + plotW, margin.top + plotH);
    ctx.stroke();

    ctx.fillStyle = '#333';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const ticks = 4;
    for (let i = 0; i <= ticks; i++) {
      const g = Math.round((maxGen * i) / ticks);
      const x = margin.left + (plotW * i) / ticks;
      const y = margin.top + plotH + 4;
      ctx.fillText(g, x, y);
    }
    ctx.textAlign = 'left';
    ctx.fillText('Поколение', margin.left, h - 20);
  }

  // --- РИСОВАНИЕ: АЛЛЕЛИ ---
  const alleleCanvas = document.getElementById('alleleCanvas');
  const alleleCtx = alleleCanvas.getContext('2d');
  const ALLELE_MARGIN = 10;

  function ensureAlleleCanvasSize() {
    const width = ALLELE_MARGIN * 2 + ALLELE_LINE_LENGTH;
    const height = ALLELE_MARGIN * 2 + GENOME_LENGTH * ALLELE_LINE_THICKNESS;
    alleleCanvas.width = width;
    alleleCanvas.height = height;
    alleleCanvas.style.width = `${width}px`;
    alleleCanvas.style.height = `${height}px`;
  }

  function computeAlleleFrequencies(pop) {
    if (!pop || pop.length === 0) return [];
    const counts = Array.from({ length: GENOME_LENGTH }, () => ({ A: 0, C: 0, G: 0, T: 0 }));
    for (const ind of pop) {
      const genome = ind.genome;
      for (let i = 0; i < GENOME_LENGTH; i++) {
        counts[i][genome[i]]++;
      }
    }
    const total = pop.length || 1;
    return counts.map(posCounts => {
      const freqs = {};
      LETTERS.forEach(letter => {
        freqs[letter] = (posCounts[letter] / total) * 100;
      });
      return freqs;
    });
  }

  function drawAlleleFrequencies(pop) {
    ensureAlleleCanvasSize();
    const freqs = computeAlleleFrequencies(pop);
    lastAlleleFreqs = freqs;
    alleleCtx.clearRect(0, 0, alleleCanvas.width, alleleCanvas.height);
    let y = ALLELE_MARGIN;
    for (let pos = 0; pos < freqs.length; pos++) {
      let x = ALLELE_MARGIN;
      LETTERS.forEach(letter => {
        const seg = (freqs[pos][letter] / 100) * ALLELE_LINE_LENGTH;
        alleleCtx.fillStyle = ALLELE_COLORS[letter];
        alleleCtx.fillRect(x, y, seg, ALLELE_LINE_THICKNESS);
        x += seg;
      });
      y += ALLELE_LINE_THICKNESS;
    }

    if (selectedAllelePos >= 0 && selectedAllelePos < GENOME_LENGTH) {
      const markerY = ALLELE_MARGIN + selectedAllelePos * ALLELE_LINE_THICKNESS;
      alleleCtx.fillStyle = ALLELE_MARKER_COLOR;
      const leftX = ALLELE_MARGIN - ALLELE_MARKER_OFFSET - ALLELE_MARKER_SIZE;
      const rightX = ALLELE_MARGIN + ALLELE_LINE_LENGTH + ALLELE_MARKER_OFFSET;
      alleleCtx.fillRect(leftX, markerY, ALLELE_MARKER_SIZE, ALLELE_MARKER_SIZE);
      alleleCtx.fillRect(rightX, markerY, ALLELE_MARKER_SIZE, ALLELE_MARKER_SIZE);
    }
    alleleCtx.strokeStyle = '#ccc';
    alleleCtx.strokeRect(ALLELE_MARGIN, ALLELE_MARGIN, ALLELE_LINE_LENGTH, GENOME_LENGTH * ALLELE_LINE_THICKNESS);
    return freqs;
  }

  // --- UI ОБНОВЛЕНИЕ ---
  const genSpan = document.getElementById('genSpan');
  const meanSpan = document.getElementById('meanSpan');
  const minSpan = document.getElementById('minSpan');
  const maxSpan = document.getElementById('maxSpan');
  const sdSpan = document.getElementById('sdSpan');
  const toggleBtn = document.getElementById('toggleBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const traitModeSelect = document.getElementById('traitModeSelect');
  const mutRateSelect = document.getElementById('mutRateSelect');
  const sigmaSlider = document.getElementById('sigmaSlider');
  const speedSlider = document.getElementById('speedSlider');
  const sigmaValue = document.getElementById('sigmaValue');
  const speedValue = document.getElementById('speedValue');
  const alleleInfo = document.getElementById('alleleInfo');

  let alleleInfoReady = false;
  let alleleInfoTitle = null;
  let alleleInfoPlaceholder = null;
  let alleleInfoContent = null;
  const alleleInfoValues = {};

  const clampAllelePos = (pos) => Math.min(Math.max(pos, 0), GENOME_LENGTH - 1);

  const sliderValueToSigma = (value) => 510 - value;
  const sliderValueToInterval = (value) => Math.max(5, BASE_INTERVAL_MS / Math.pow(2, value));

  function selectAllele(pos) {
    selectedAllelePos = clampAllelePos(pos);
    drawAlleleFrequencies(population);
    showAlleleInfo(selectedAllelePos);
  }

  function ensureAlleleInfoElements() {
    if (alleleInfoReady) return;

    alleleInfo.innerHTML = '';

    alleleInfoPlaceholder = document.createElement('div');
    alleleInfoPlaceholder.className = 'allele-info-placeholder';
    alleleInfoPlaceholder.textContent = 'Загружаем данные...';
    alleleInfo.appendChild(alleleInfoPlaceholder);

    alleleInfoContent = document.createElement('div');
    alleleInfoContent.className = 'allele-info-content';
    alleleInfo.appendChild(alleleInfoContent);

    alleleInfoTitle = document.createElement('div');
    alleleInfoTitle.className = 'allele-info-title';
    alleleInfoContent.appendChild(alleleInfoTitle);

    LETTERS.forEach(letter => {
      const row = document.createElement('div');
      row.className = 'allele-info-row';

      const swatch = document.createElement('div');
      swatch.className = 'allele-legend-swatch';
      swatch.style.background = ALLELE_COLORS[letter];

      const text = document.createElement('div');
      alleleInfoValues[letter] = text;

      row.appendChild(swatch);
      row.appendChild(text);
      alleleInfoContent.appendChild(row);
    });

    alleleInfoReady = true;
  }

  function showAlleleInfo(pos) {
    ensureAlleleInfoElements();

    if (!lastAlleleFreqs || lastAlleleFreqs.length === 0) {
      alleleInfoPlaceholder.textContent = 'Нажмите на строку, чтобы увидеть вклад букв для позиции.';
      alleleInfoPlaceholder.style.display = 'block';
      alleleInfoContent.style.display = 'none';
      return;
    }

    alleleInfoPlaceholder.style.display = 'none';
    alleleInfoContent.style.display = 'block';

    if (pos < 0 || pos >= GENOME_LENGTH) {
      pos = selectedAllelePos;
    }
    selectedAllelePos = pos;

    const effects = effectMap[pos];
    const freqs = lastAlleleFreqs[pos];
    alleleInfoTitle.textContent = `Позиция ${pos}`;

    LETTERS.forEach(letter => {
      const effectVal = effects[letter];
      const freqVal = freqs ? freqs[letter] : 0;
      alleleInfoValues[letter].textContent = `${letter}: ${effectVal >= 0 ? '+' : ''}${effectVal} см, ${freqVal.toFixed(1)}%`;
    });
  }

  function updateSigmaFromSlider() {
    const v = parseFloat(sigmaSlider.value);
    selectionSigma = sliderValueToSigma(!Number.isNaN(v) ? v : 810);
    sigmaValue.textContent = selectionSigma.toFixed(0);
  }

  function updateSpeedFromSlider() {
    const v = parseFloat(speedSlider.value);
    stepIntervalMs = sliderValueToInterval(!Number.isNaN(v) ? v : 0);
    const text = stepIntervalMs.toFixed(1).replace(/\.0$/, '');
    speedValue.textContent = text;
    if (isRunning) {
      clearInterval(intervalId);
      intervalId = setInterval(stepSimulation, stepIntervalMs);
    }
  }

  function updateMutationFromSelect() {
    const v = parseFloat(mutRateSelect.value);
    if (!Number.isNaN(v) && v >= 0) {
      mutationRate = v;
    }
  }

  function updateStatsUI() {
    const last = history[history.length - 1];
    genSpan.textContent = last.gen;
    meanSpan.textContent = last.mean.toFixed(1);
    minSpan.textContent = last.min.toFixed(1);
    maxSpan.textContent = last.max.toFixed(1);
    sdSpan.textContent = last.sd.toFixed(2);
  }

  function updateUI() {
    drawHistogram(population);
    drawTimeSeries();
    drawAlleleFrequencies(population);
    updateStatsUI();
    showAlleleInfo(selectedAllelePos);
  }

  // --- СИМУЛЯЦИЯ ---
  function initSimulation() {
    isRunning = false;
    if (intervalId !== null) {
      clearInterval(intervalId);
      intervalId = null;
    }
    traitModeSelect.disabled = false;
    generation = 0;
    history = [];
    selectedAllelePos = 0;
    lastAlleleFreqs = [];
    traitMode = traitModeSelect.value === TRAIT_MODES.MONOGENIC ? TRAIT_MODES.MONOGENIC : TRAIT_MODES.POLYGENIC;
    initGenetics();

    updateMutationFromSelect();
    updateSigmaFromSlider();
    updateSpeedFromSlider();

    population = new Array(POP_SIZE);
    for (let i = 0; i < POP_SIZE; i++) {
      const genome = randomInitialGenome();
      const neck = computeNeck(genome);
      population[i] = { genome, neck };
    }
    recordStats();
    updateUI();
    toggleBtn.textContent = 'Старт';
  }

  function stepSimulation() {
    population = makeNextGeneration(population);
    generation++;
    recordStats();
    updateUI();
  }

  function startSimulation() {
    if (isRunning) return;
    isRunning = true;
    toggleBtn.textContent = 'Пауза';
    traitModeSelect.disabled = true;
    intervalId = setInterval(stepSimulation, stepIntervalMs);
  }

  function stopSimulation() {
    if (!isRunning) return;
    isRunning = false;
    toggleBtn.textContent = 'Старт';
    traitModeSelect.disabled = false;
    if (intervalId !== null) {
      clearInterval(intervalId);
      intervalId = null;
    }
  }

  // --- ОБРАБОТЧИКИ ---
  toggleBtn.addEventListener('click', () => {
    if (isRunning) stopSimulation();
    else startSimulation();
  });

  stepBtn.addEventListener('click', () => {
    if (!isRunning) {
      stepSimulation();
    }
  });

  resetBtn.addEventListener('click', () => {
    initSimulation();
  });

  traitModeSelect.addEventListener('change', () => {
    traitMode = traitModeSelect.value === TRAIT_MODES.MONOGENIC ? TRAIT_MODES.MONOGENIC : TRAIT_MODES.POLYGENIC;
    initSimulation();
  });

  mutRateSelect.addEventListener('change', updateMutationFromSelect);
  sigmaSlider.addEventListener('input', updateSigmaFromSlider);
  speedSlider.addEventListener('input', updateSpeedFromSlider);

  alleleCanvas.addEventListener('click', (evt) => {
    const rect = alleleCanvas.getBoundingClientRect();
    const scaleY = alleleCanvas.height / rect.height;
    const y = (evt.clientY - rect.top) * scaleY;
    const pos = Math.floor((y - ALLELE_MARGIN) / ALLELE_LINE_THICKNESS);
    if (pos >= 0 && pos < GENOME_LENGTH) {
      selectAllele(pos);
      alleleCanvas.focus({ preventScroll: true });
    } else {
      showAlleleInfo(-1);
    }
  });

  alleleCanvas.addEventListener('keydown', (evt) => {
    if (evt.key === 'ArrowUp' || evt.key === 'ArrowDown') {
      evt.preventDefault();
      const delta = evt.key === 'ArrowUp' ? -1 : 1;
      selectAllele(selectedAllelePos + delta);
    }
  });

  function resizeCanvases() {
    [histCanvas, timeCanvas].forEach(canvas => {
      const rect = canvas.getBoundingClientRect();
      const cssWidth = canvas.clientWidth || rect.width;
      const cssHeight = canvas.clientHeight || rect.height;
      if (rect.width > 0) {
        const ratio = window.devicePixelRatio || 1;
        canvas.style.width = `${cssWidth}px`;
        canvas.style.height = `${cssHeight}px`;
        canvas.width = Math.round(rect.width * ratio);
        canvas.height = Math.round(rect.height * ratio);
        const ctx = canvas.getContext('2d');
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      }
    });
    updateUI();
  }
  window.addEventListener('resize', resizeCanvases);

  // Старт
  showAlleleInfo(-1);
  initSimulation();
  resizeCanvases();
})();
</script>
</body>
</html>
