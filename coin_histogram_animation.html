<!--
Interactive science demo.
Part of the "science-demos" project.

GitHub: https://github.com/yupic/science-demos
YouTube: https://www.youtube.com/@autism-ru
Telegram: https://t.me/autism_science
License: MIT
-->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Распределение числа орлов</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
<div class="container">
  <h1>Распределение числа выпавших орлов</h1>
  <p class="desc">Сколько орлов выпадает при многократном подбрасывании набора монет. Нажмите «Старт», чтобы увидеть, как гистограмма стремится к биномиальному распределению.</p>
  <div class="controls">
    <button id="toggleBtn">Старт</button>
    <button id="stepBtn">1 шаг</button>
    <button id="resetBtn">Сбросить</button>
    <label class="mut-label">Монет:
      <input type="number" id="coinCount" min="1" max="5000" value="100" />
    </label>
    <label class="mut-label">Масштаб:
      <select id="scaleMode">
        <option value="full" selected>Полный</option>
        <option value="auto">Авто</option>
      </select>
    </label>
    <label class="slider-label">Скорость:
      <input type="range" id="speed" min="1" max="20" value="1" />
      <span id="speedValue" class="slider-value">1× (30/с)</span>
    </label>
  </div>
  <div class="stats">Сделано бросков: <span id="trialCount">0</span></div>
  <div class="canvas-frame">
    <canvas id="histCanvas"></canvas>
  </div>
</div>
<div class="footer">
  © autism_science • MIT License •
  <a href="https://github.com/yupic/science-demos" target="_blank" rel="noopener">GitHub</a> •
  <a href="https://www.youtube.com/@autism-ru" target="_blank" rel="noopener">YouTube</a> •
  <a href="https://t.me/autism_science" target="_blank" rel="noopener">Telegram</a>
</div>
<script>
  const canvas = document.getElementById('histCanvas');
  const ctx = canvas.getContext('2d');
  const coinInput = document.getElementById('coinCount');
  const stepBtn = document.getElementById('stepBtn');
  const toggleBtn = document.getElementById('toggleBtn');
  const resetBtn = document.getElementById('resetBtn');
  const speedSlider = document.getElementById('speed');
  const speedValue = document.getElementById('speedValue');
  const trialCountSpan = document.getElementById('trialCount');
  const scaleModeSelect = document.getElementById('scaleMode');

  let coinCount = 100;
  let counts = new Array(coinCount + 1).fill(0);
  let totalTrials = 0;
  let running = false;
  let lastTime = 0;
  let fractionalSteps = 0;
  let hoveredIndex = null;
  let animationId = null;
  let scaleMode = 'full';

  const hoverInfoSpan = (() => {
    const statsLine = document.querySelector('.stats');
    const span = document.createElement('span');
    span.style.marginLeft = '12px';
    span.id = 'hoverInfo';
    span.textContent = '';
    statsLine.appendChild(span);
    return span;
  })();

  function setRunningState(isRunning) {
    running = isRunning;
    toggleBtn.textContent = running ? 'Пауза' : 'Старт';
    coinInput.disabled = running;
  }

  function defaultDisplayIndex() {
    const center = Math.floor(coinCount / 2);
    const alt = Math.min(coinCount, center + 1);
    if (coinCount % 2 === 0 && totalTrials > 0) {
      return (counts[alt] || 0) > (counts[center] || 0) ? alt : center;
    }
    return center;
  }

  function updateSpeedLabel() {
    const s = Number(speedSlider.value);
    const rate = 30 * Math.pow(2, s - 1);
    speedValue.textContent = `${s}× (${rate.toLocaleString('ru-RU')}/с)`;
  }

  function resetSimulation() {
    const parsed = parseInt(coinInput.value, 10);
    coinCount = Number.isFinite(parsed) && parsed > 0 ? Math.min(parsed, 5000) : 100;
    coinInput.value = coinCount;
    counts = new Array(coinCount + 1).fill(0);
    totalTrials = 0;
    fractionalSteps = 0;
    hoveredIndex = null;
    trialCountSpan.textContent = formatCount(totalTrials);
    updateHoverInfo();
    draw();
  }

  function simulateOnce() {
    let heads = 0;
    for (let i = 0; i < coinCount; i++) {
      if (Math.random() < 0.5) heads++;
    }
    counts[heads] += 1;
    totalTrials += 1;
  }

  function simulateMany(n) {
    for (let i = 0; i < n; i++) simulateOnce();
  }

  function formatCount(n) {
    return n.toLocaleString('ru-RU');
  }

  function generateSuperscript(exp) {
    const map = {
      '-': '\u207b',
      '0': '\u2070',
      '1': '\u00b9',
      '2': '\u00b2',
      '3': '\u00b3',
      '4': '\u2074',
      '5': '\u2075',
      '6': '\u2076',
      '7': '\u2077',
      '8': '\u2078',
      '9': '\u2079'
    };
    return String(exp)
      .split('')
      .map((c) => map[c] ?? c)
      .join('');
  }

  function generateXTicks(domain, widthPx, minLabelGapPx = 34) {
    const width = Math.max(0, widthPx);
    const maxLabels = Math.floor(width / minLabelGapPx);
    if (maxLabels < 2) return [];

    const range = Math.abs(domain.max - domain.min);
    if (range === 0) return [domain.min];

    const targetLabels = Math.min(maxLabels, 31);
    let rawStep = range / (targetLabels - 1);
    const m = Math.pow(10, Math.floor(Math.log10(rawStep)));
    const x = rawStep / m;
    let niceBase;
    if (x <= 1) niceBase = 1;
    else if (x <= 2) niceBase = 2;
    else if (x <= 5) niceBase = 5;
    else niceBase = 10;
    let step = Math.max(1, niceBase * m);

    const buildTicks = () => {
      const ticks = [];
      const start = Math.ceil(domain.min / step) * step;
      for (let v = start; v <= domain.max + step * 0.001; v += step) {
        const rounded = Number((Math.round(v / step) * step).toFixed(10));
        ticks.push(rounded);
      }
      return ticks;
    };

    let ticks = buildTicks();
    if (ticks.length > maxLabels) {
      step *= 2;
      ticks = buildTicks();
    }
    return ticks;
  }

  function generateYTicks(maxProb) {
    const maxValue = maxProb > 0 ? maxProb : 1;
    const ticks = Array.from({ length: 5 }, (_, i) => (maxValue * i) / 4);
    return { ticks, maxValue };
  }

  function calculateRange() {
    if (scaleMode !== 'auto') {
      return { min: 0, max: coinCount };
    }

    const mean = coinCount / 2;
    const sd = Math.sqrt(coinCount) / 2;
    const baseMin = mean - 2 * sd;
    const baseMax = mean + 2 * sd;

    if (totalTrials === 0) {
      return { min: baseMin, max: baseMax };
    }

    let minObserved = null;
    let maxObserved = null;
    for (let i = 0; i < counts.length; i++) {
      if (counts[i] > 0) {
        if (minObserved === null) minObserved = i;
        maxObserved = i;
      }
    }

    if (minObserved === null) {
      return { min: baseMin, max: baseMax };
    }

    if (minObserved >= baseMin && maxObserved <= baseMax) {
      return { min: baseMin, max: baseMax };
    }

    const distance = Math.max(Math.abs(mean - minObserved), Math.abs(mean - maxObserved));
    const min = mean - distance;
    const max = mean + distance;
    if (Math.abs(max - min) < 1e-6) {
      return { min: min - 1, max: max + 1 };
    }
    return {
      min: Math.max(0, min),
      max: Math.min(coinCount, max)
    };
  }

  function draw() {
    const { min: xMin, max: xMax } = calculateRange();
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;
    const dpr = window.devicePixelRatio || 1;
    const displayWidth = canvas.clientWidth || canvas.parentElement.clientWidth || 600;
    const targetHeight = Math.max(280, Math.min(window.innerHeight * 0.6, 520));
    canvas.style.height = `${targetHeight}px`;
    canvas.width = Math.floor(displayWidth * dpr);
    canvas.height = Math.floor(targetHeight * dpr);

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    const marginLeft = 64;
    const marginRight = 16;
    const marginBottom = 40;
    const marginTop = 18;
    const innerWidth = width - marginLeft - marginRight;
    const innerHeight = height - marginTop - marginBottom;

    const maxCount = Math.max(...counts, 0);
    const maxProb = totalTrials > 0 && maxCount > 0 ? maxCount / totalTrials : 0;
    const { ticks: yTicks, maxValue: yMax } = generateYTicks(maxProb);
    const scaleY = yMax > 0 ? innerHeight / yMax : 0;

    ctx.fillStyle = '#f8f9fc';
    ctx.fillRect(marginLeft, marginTop, innerWidth, innerHeight);

    const barWidth = innerWidth / xRange;
    ctx.fillStyle = '#2c7be5';
    for (let i = 0; i < counts.length; i++) {
      const count = counts[i];
      if (count === 0) continue;
      const xLeft = marginLeft + ((i - 0.5 - xMinEdge) / xRange) * innerWidth;
      const prob = totalTrials > 0 ? count / totalTrials : 0;
      const h = Math.max(2, prob * scaleY);
      const y = marginTop + innerHeight - h;
      if (xLeft + barWidth < marginLeft || xLeft > width - marginRight) continue;
      const drawWidth = Math.max(1, barWidth * 0.9);
      const x = xLeft + (barWidth - drawWidth) / 2;
      ctx.fillRect(x, y, drawWidth, h);
    }

    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(marginLeft, marginTop + innerHeight);
    ctx.lineTo(width - marginRight, marginTop + innerHeight);
    ctx.stroke();

    ctx.fillStyle = '#444';
    ctx.font = '12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const labelValues = generateXTicks({ min: xMin, max: xMax }, innerWidth);
    const stepForFormat = labelValues.length >= 2 ? Math.abs(labelValues[1] - labelValues[0]) : 1;
    const decimals = stepForFormat >= 1 ? 0 : Math.max(0, Math.min(6, Math.ceil(-Math.log10(stepForFormat))));
    const formatTick = (value) => {
      if (decimals === 0) return Math.round(value).toString();
      return Number(value.toFixed(decimals)).toString();
    };

    for (const value of labelValues) {
      const x = marginLeft + ((value - xMinEdge) / xRange) * innerWidth;
      const label = formatTick(value);
      ctx.fillText(label, x, marginTop + innerHeight + 6);
    }

    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (const prob of yTicks) {
      const y = marginTop + innerHeight - (prob / yMax) * innerHeight;
      ctx.fillText(`${(prob * 100).toFixed(2)}%`, marginLeft - 8, y);
    }

    ctx.save();
    const yLabelX = Math.max(4, marginLeft - 74);
    ctx.translate(yLabelX, marginTop + innerHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('Вероятность', 0, 0);
    ctx.restore();

    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  function formatProbability(prob) {
    if (prob === 0) return '0';
    const percent = prob * 100;
    if (percent >= 0.01) return `${percent.toFixed(2)}%`;
    let exp = Math.floor(Math.log10(percent));
    let mantissa = Number((percent / Math.pow(10, exp)).toFixed(0));
    if (mantissa >= 10) {
      mantissa = 1.0;
      exp += 1;
    }
    return `${mantissa.toFixed(0)}×10${generateSuperscript(exp)} %`;
  }

  function updateHoverInfo() {
    const index = hoveredIndex === null ? defaultDisplayIndex() : hoveredIndex;
    const count = counts[index] || 0;
    const prob = totalTrials > 0 ? count / totalTrials : 0;
    hoverInfoSpan.textContent = `| Орлы/решки: ${index}/${coinCount - index}, выпало ${formatCount(count)} раз, вероятность ${formatProbability(prob)}`;
  }

  function toggleRun() {
    setRunningState(!running);
    if (running) {
      lastTime = 0;
      if (animationId === null) {
        animationId = requestAnimationFrame(loop);
      }
    }
  }

  function loop(timestamp) {
    if (!running) {
      animationId = null;
      lastTime = 0;
      return;
    }

    if (!lastTime) lastTime = timestamp;
    const delta = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    const speed = Number(speedSlider.value);
    const rate = 30 * Math.pow(2, speed - 1);
    const expectedSteps = delta * rate + fractionalSteps;
    let steps = Math.floor(expectedSteps);
    fractionalSteps = expectedSteps - steps;
    steps = Math.min(steps, 30000);
    if (steps > 0) {
      simulateMany(steps);
      trialCountSpan.textContent = formatCount(totalTrials);
    }

    draw();
    updateHoverInfo();
    animationId = requestAnimationFrame(loop);
  }

  function handleMouseMove(event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const marginLeft = 64;
    const marginRight = 16;
    const innerWidth = rect.width - marginLeft - marginRight;
    const { min: xMin, max: xMax } = calculateRange();
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;

    if (x < marginLeft || x > rect.width - marginRight) {
      updateHoverInfo();
      return;
    }

    const barWidth = innerWidth / xRange;
    const value = xMinEdge + ((x - marginLeft) / innerWidth) * xRange;
    let idx = Math.round(value);
    idx = Math.max(0, Math.min(coinCount, idx));
    hoveredIndex = idx;
    updateHoverInfo();
  }

  function hideTooltip() {
    updateHoverInfo();
  }

  coinInput.addEventListener('change', resetSimulation);
  scaleModeSelect.addEventListener('change', (e) => {
    scaleMode = e.target.value;
    draw();
  });
  stepBtn.addEventListener('click', () => {
    simulateMany(1);
    trialCountSpan.textContent = formatCount(totalTrials);
    draw();
    updateHoverInfo();
  });
  toggleBtn.addEventListener('click', toggleRun);
  resetBtn.addEventListener('click', () => {
    setRunningState(false);
    resetSimulation();
  });
  speedSlider.addEventListener('input', updateSpeedLabel);

  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mouseleave', hideTooltip);
  window.addEventListener('resize', draw);

  updateSpeedLabel();
  resetSimulation();
</script>
</body>
</html>
