<!--
Interactive science demo.
Part of the "science-demos" project.

GitHub: https://github.com/yupic/science-demos
YouTube: https://www.youtube.com/@autism-ru
Telegram: https://t.me/autism_science
License: MIT
-->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Распределение числа орлов (несколько вероятностей)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f5f5f5;
      --fg: #222;
      --accent: #2c7be5;
      --muted: #666;
      --card: #fff;
      --border: #ddd;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--fg);
    }
    .container {
      margin: 0 auto;
      padding: 0 16px;
      width: 100%;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 20px;
    }
    p.desc {
      margin: 0 0 14px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.5;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 10px;
      align-items: center;
    }
    button {
      border: 1px solid var(--border);
      background: var(--card);
      border-radius: 6px;
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    button:hover { background: #f0f4ff; }
    button:active {
      transform: translateY(1px);
      box-shadow: 0 0 0 rgba(0,0,0,0.05);
    }
    select, input[type="number"] {
      padding: 6px 8px;
      font-size: 14px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--card);
    }
    .mut-label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
    }
    .probability-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 6px;
      margin-bottom: 10px;
    }
    .probability-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .probability-row input {
      width: 120px;
    }
    .probability-row .color-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid var(--border);
      flex-shrink: 0;
    }
    .canvas-frame {
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      overflow: hidden;
      position: relative;
      width: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      background: #fff;
    }
    .note {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
      line-height: 1.5;
    }
    @media (max-width: 600px) {
      h1 { font-size: 20px; }
      .probability-row input { width: 100px; }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Распределение числа выпавших орлов</h1>
  <p class="desc">Сравните гистограммы для разной вероятности выпадения орла. Укажите число монет, число бросков и несколько вариантов вероятностей, затем нажмите «Создать».</p>
  <div class="controls">
    <button id="createBtn">Создать</button>
    <label class="mut-label">Монет:
      <input type="number" id="coinCount" min="1" max="5000" value="100" />
    </label>
    <label class="mut-label">Количество бросков:
      <input type="number" id="trialCount" min="1" max="2000000" value="100000" />
    </label>
  </div>
  <div class="probability-section">
    <div class="probability-list" id="probabilityList"></div>
    <button id="addProbBtn">Добавить вероятность</button>
  </div>
  <div class="canvas-frame">
    <canvas id="histCanvas"></canvas>
  </div>
  <div class="note">Цвета гистограмм полупрозрачные, поэтому распределения могут накладываться друг на друга. Максимальное число бросков — 2&nbsp;000&nbsp;000.</div>
</div>
<div style="margin: 10px 0; font-size:12px; color:#999; text-align:center;">
  © autism_science • MIT License •
  <a href="https://github.com/yupic/science-demos" target="_blank" rel="noopener" style="color:#999;">GitHub</a> •
  <a href="https://www.youtube.com/@autism-ru" target="_blank" rel="noopener" style="color:#999;">YouTube</a> •
  <a href="https://t.me/autism_science" target="_blank" rel="noopener" style="color:#999;">Telegram</a>
</div>
<script>
  const canvas = document.getElementById('histCanvas');
  const ctx = canvas.getContext('2d');
  const coinInput = document.getElementById('coinCount');
  const trialInput = document.getElementById('trialCount');
  const createBtn = document.getElementById('createBtn');
  const addProbBtn = document.getElementById('addProbBtn');
  const probabilityList = document.getElementById('probabilityList');

  const colors = [
    'rgba(44, 123, 229, 0.45)',
    'rgba(227, 52, 47, 0.45)',
    'rgba(52, 168, 83, 0.45)',
    'rgba(255, 193, 7, 0.45)',
    'rgba(156, 39, 176, 0.45)',
    'rgba(0, 188, 212, 0.45)',
    'rgba(255, 87, 34, 0.45)'
  ];

  let datasets = [];
  let hoveredIndex = null;

  function clampInt(value, min, max, fallback) {
    const n = parseInt(value, 10);
    if (!Number.isFinite(n)) return fallback;
    return Math.min(Math.max(n, min), max);
  }

  function formatCount(value) {
    return value.toLocaleString('ru-RU');
  }

  function formatProbability(prob) {
    return `${(prob * 100).toFixed(2)}%`;
  }

  function createProbabilityRow(defaultValue = 50) {
    const row = document.createElement('div');
    row.className = 'probability-row';

    const colorDot = document.createElement('div');
    colorDot.className = 'color-dot';
    const color = colors[(probabilityList.children.length) % colors.length];
    colorDot.style.background = color;

    const label = document.createElement('label');
    label.className = 'mut-label';
    label.textContent = 'Вероятность выпадения орла, %:';

    const input = document.createElement('input');
    input.type = 'number';
    input.min = '0';
    input.max = '100';
    input.value = defaultValue;
    input.addEventListener('change', () => {
      const v = clampInt(input.value, 0, 100, defaultValue);
      input.value = v;
    });

    label.appendChild(input);

    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Удалить';
    removeBtn.addEventListener('click', () => {
      probabilityList.removeChild(row);
      datasets = [];
      draw([]);
      refreshColorDots();
      if (probabilityList.children.length === 0) {
        addDefaultRow();
      }
    });

    const info = document.createElement('span');
    info.className = 'prob-info';
    info.style.fontSize = '12px';
    info.style.color = '#555';

    row.appendChild(colorDot);
    row.appendChild(label);
    row.appendChild(removeBtn);
    row.appendChild(info);
    probabilityList.appendChild(row);
  }

  function refreshColorDots() {
    Array.from(probabilityList.children).forEach((row, idx) => {
      const dot = row.querySelector('.color-dot');
      dot.style.background = colors[idx % colors.length];
    });
  }

  function addDefaultRow() {
    createProbabilityRow(50);
  }

  function sampleHeads(n, p) {
    let heads = 0;
    for (let i = 0; i < n; i++) {
      if (Math.random() < p) heads += 1;
    }
    return heads;
  }

  function simulateDataset(coinCount, trials, p) {
    const counts = new Array(coinCount + 1).fill(0);
    for (let i = 0; i < trials; i++) {
      const heads = sampleHeads(coinCount, p);
      counts[heads] += 1;
    }
    return counts;
  }

  function generateXTicks(domain, widthPx, minLabelGapPx = 34) {
    const width = Math.max(0, widthPx);
    const maxLabels = Math.floor(width / minLabelGapPx);
    if (maxLabels < 2) return [];

    const range = Math.abs(domain.max - domain.min);
    if (range === 0) return [domain.min];

    const targetLabels = Math.min(maxLabels, 31);
    let rawStep = range / (targetLabels - 1);
    const m = Math.pow(10, Math.floor(Math.log10(rawStep)));
    const x = rawStep / m;
    let niceBase;
    if (x <= 1) niceBase = 1;
    else if (x <= 2) niceBase = 2;
    else if (x <= 5) niceBase = 5;
    else niceBase = 10;
    let step = Math.max(1, niceBase * m);

    const buildTicks = () => {
      const ticks = [];
      const start = Math.ceil(domain.min / step) * step;
      for (let v = start; v <= domain.max + step * 0.001; v += step) {
        const rounded = Number((Math.round(v / step) * step).toFixed(10));
        ticks.push(rounded);
      }
      return ticks;
    };

    let ticks = buildTicks();
    if (ticks.length > maxLabels) {
      step *= 2;
      ticks = buildTicks();
    }
    return ticks;
  }

  function generateYTicks(maxProb) {
    const maxValue = maxProb > 0 ? maxProb : 1;
    const ticks = Array.from({ length: 5 }, (_, i) => (maxValue * i) / 4);
    return { ticks, maxValue };
  }

  function draw(simulatedDatasets) {
    const coinCountValue = clampInt(coinInput.value, 1, 5000, 100);
    coinInput.value = coinCountValue;

    const { min: xMin, max: xMax } = { min: 0, max: coinCountValue };
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;
    const dpr = window.devicePixelRatio || 1;
    const displayWidth = canvas.clientWidth || canvas.parentElement.clientWidth || 600;
    const targetHeight = Math.max(280, Math.min(window.innerHeight * 0.6, 520));
    canvas.style.height = `${targetHeight}px`;
    canvas.width = Math.floor(displayWidth * dpr);
    canvas.height = Math.floor(targetHeight * dpr);

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    const marginLeft = 64;
    const marginRight = 16;
    const marginBottom = 40;
    const marginTop = 18;
    const innerWidth = width - marginLeft - marginRight;
    const innerHeight = height - marginTop - marginBottom;

    ctx.fillStyle = '#f8f9fc';
    ctx.fillRect(marginLeft, marginTop, innerWidth, innerHeight);

    if (!simulatedDatasets || simulatedDatasets.length === 0) {
      drawAxesOnly({ xMin, xMax, marginLeft, marginTop, innerWidth, innerHeight, width, height });
      updateHoverInfo(null);
      return;
    }

    let globalMaxProb = 0;
    simulatedDatasets.forEach(({ counts, trials }) => {
      const maxCount = Math.max(...counts, 0);
      const maxProb = trials > 0 && maxCount > 0 ? maxCount / trials : 0;
      globalMaxProb = Math.max(globalMaxProb, maxProb);
    });

    const { ticks: yTicks, maxValue: yMax } = generateYTicks(globalMaxProb);
    const scaleY = yMax > 0 ? innerHeight / yMax : 0;

    simulatedDatasets.forEach(({ counts, color, trials }) => {
      ctx.fillStyle = color;
      const barWidth = innerWidth / xRange;
      for (let i = 0; i < counts.length; i++) {
        const count = counts[i];
        if (count === 0) continue;
        const xLeft = marginLeft + ((i - 0.5 - xMinEdge) / xRange) * innerWidth;
        const prob = trials > 0 ? count / trials : 0;
        const h = Math.max(2, prob * scaleY);
        const y = marginTop + innerHeight - h;
        if (xLeft + barWidth < marginLeft || xLeft > width - marginRight) continue;
        const drawWidth = Math.max(1, barWidth * 0.9);
        const x = xLeft + (barWidth - drawWidth) / 2;
        ctx.fillRect(x, y, drawWidth, h);
      }
    });

    drawAxesOnly({ xMin, xMax, marginLeft, marginTop, innerWidth, innerHeight, width, height, yTicks, yMax });
    updateHoverInfo();
  }

  function drawAxesOnly({ xMin, xMax, marginLeft, marginTop, innerWidth, innerHeight, width, height, yTicks = [0, 0.25, 0.5, 0.75, 1], yMax = 1 }) {
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;
    const marginRight = 16;
    const marginBottom = 40;

    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(marginLeft, marginTop + innerHeight);
    ctx.lineTo(width - marginRight, marginTop + innerHeight);
    ctx.stroke();

    ctx.fillStyle = '#444';
    ctx.font = '12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const labelValues = generateXTicks({ min: xMin, max: xMax }, innerWidth);
    const stepForFormat = labelValues.length >= 2 ? Math.abs(labelValues[1] - labelValues[0]) : 1;
    const decimals = stepForFormat >= 1 ? 0 : Math.max(0, Math.min(6, Math.ceil(-Math.log10(stepForFormat))));
    const formatTick = (value) => {
      if (decimals === 0) return Math.round(value).toString();
      return Number(value.toFixed(decimals)).toString();
    };

    for (const value of labelValues) {
      const x = marginLeft + ((value - xMinEdge) / xRange) * innerWidth;
      const label = formatTick(value);
      ctx.fillText(label, x, marginTop + innerHeight + 6);
    }

    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (const prob of yTicks) {
      const y = marginTop + innerHeight - (prob / yMax) * innerHeight;
      ctx.fillText(`${(prob * 100).toFixed(2)}%`, marginLeft - 8, y);
    }

    ctx.save();
    const yLabelX = Math.max(4, marginLeft - 74);
    ctx.translate(yLabelX, marginTop + innerHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('Вероятность', 0, 0);
    ctx.restore();

    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  function collectProbabilities() {
    const values = [];
    Array.from(probabilityList.children).forEach((row, idx) => {
      const input = row.querySelector('input');
      const value = clampInt(input.value, 0, 100, 50);
      input.value = value;
      const color = colors[idx % colors.length];
      values.push({ p: value / 100, label: `${value}%`, color });
    });
    return values;
  }

  function updateHoverInfo(index = hoveredIndex) {
    if (!datasets.length) {
      Array.from(probabilityList.children).forEach((row) => {
        const info = row.querySelector('.prob-info');
        if (info) info.textContent = '';
      });
      return;
    }

    const datasetCoinCount = datasets[0]?.counts.length ? datasets[0].counts.length - 1 : clampInt(coinInput.value, 1, 5000, 100);
    const displayIndex = index === null ? Math.floor(datasetCoinCount / 2) : Math.max(0, Math.min(datasetCoinCount, index));

    Array.from(probabilityList.children).forEach((row, idx) => {
      const info = row.querySelector('.prob-info');
      const dataset = datasets[idx];
      if (!info || !dataset) {
        if (info) info.textContent = '';
        return;
      }
      const currentCoinCount = dataset.counts.length - 1;
      const clampedIndex = Math.min(displayIndex, currentCoinCount);
      const count = dataset.counts[clampedIndex] || 0;
      const prob = dataset.trials > 0 ? count / dataset.trials : 0;
      info.textContent = `Орлы/решки: ${clampedIndex}/${currentCoinCount - clampedIndex}, выпало ${formatCount(count)} раз, вероятность ${formatProbability(prob)}`;
    });
  }

  function handleMouseMove(event) {
    if (!datasets.length) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const marginLeft = 64;
    const marginRight = 16;
    const innerWidth = rect.width - marginLeft - marginRight;
    const coinCountValue = datasets[0]?.counts.length ? datasets[0].counts.length - 1 : clampInt(coinInput.value, 1, 5000, 100);
    const xMin = 0;
    const xMax = coinCountValue;
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;

    if (x < marginLeft || x > rect.width - marginRight) {
      hoveredIndex = null;
      updateHoverInfo();
      return;
    }

    const value = xMinEdge + ((x - marginLeft) / innerWidth) * xRange;
    let idx = Math.round(value);
    idx = Math.max(0, Math.min(coinCountValue, idx));
    hoveredIndex = idx;
    updateHoverInfo(hoveredIndex);
  }

  function handleMouseLeave() {
    hoveredIndex = null;
    updateHoverInfo();
  }

  function handleCreate() {
    const coinCountValue = clampInt(coinInput.value, 1, 5000, 100);
    const trialCountValue = clampInt(trialInput.value, 1, 2000000, 100000);
    coinInput.value = coinCountValue;
    trialInput.value = trialCountValue;

    const probabilities = collectProbabilities();
    if (probabilities.length === 0) {
      addDefaultRow();
      return;
    }

    const simulatedDatasets = probabilities.map(({ p, label, color }) => {
      const counts = simulateDataset(coinCountValue, trialCountValue, p);
      return { counts, label, color, trials: trialCountValue };
    });

    datasets = simulatedDatasets;
    draw(datasets);
    updateHoverInfo();
  }

  addProbBtn.addEventListener('click', () => {
    createProbabilityRow(50);
    refreshColorDots();
  });

  createBtn.addEventListener('click', handleCreate);
  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mouseleave', handleMouseLeave);
  window.addEventListener('resize', () => draw(datasets));

  addDefaultRow();
  draw([]);
</script>
</body>
</html>
