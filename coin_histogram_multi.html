<!--
Interactive science demo.
Part of the "science-demos" project.

GitHub: https://github.com/yupic/science-demos
YouTube: https://www.youtube.com/@autism-ru
Telegram: https://t.me/autism_science
License: MIT
-->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Сравнение вероятностей</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
  <script src="sd.js"></script>
</head>
<body>
<div class="container">
  <h1>Сравнение распределений выпадения орлов</h1>
  <p class="desc">Сравните гистограммы для разной вероятности выпадения орла. Укажите число монет и несколько вариантов вероятностей.</p>
  <div class="controls">
    <label class="mut-label">Монет:
      <input type="number" id="coinCount" min="1" max="5000" value="100" />
    </label>
    <label class="mut-label">Масштаб:
      <select id="scaleMode">
        <option value="full" selected>Полный</option>
        <option value="auto">Авто</option>
      </select>
    </label>
    <label class="mut-label">Добавить/удалить гистограмму:</label>
    <div class="prob-actions">
      <button id="addProbBtn">➕</button>
      <button id="removeProbBtn" disabled>❌</button>
    </div>
  </div>
  <div class="probability-section">
    <div class="probability-list" id="probabilityList"></div>
  </div>
  <div class="canvas-frame">
    <canvas id="histCanvas"></canvas>
  </div>
</div>
<div class="footer">
  © autism_science • MIT License •
  <a href="https://github.com/yupic/science-demos" target="_blank" rel="noopener">GitHub</a> •
  <a href="https://www.youtube.com/@autism-ru" target="_blank" rel="noopener">YouTube</a> •
  <a href="https://t.me/autism_science" target="_blank" rel="noopener">Telegram</a>
</div>
<script>
  const canvas = document.getElementById('histCanvas');
  const ctx = canvas.getContext('2d');
  const coinInput = document.getElementById('coinCount');
  const addProbBtn = document.getElementById('addProbBtn');
  const removeProbBtn = document.getElementById('removeProbBtn');
  const probabilityList = document.getElementById('probabilityList');
  const scaleModeSelect = document.getElementById('scaleMode');

  const colors = [
    'rgba(44, 123, 229, 0.45)',
    'rgba(227, 52, 47, 0.45)',
    'rgba(52, 168, 83, 0.45)',
    'rgba(255, 193, 7, 0.45)',
    'rgba(156, 39, 176, 0.45)',
    'rgba(0, 188, 212, 0.45)',
    'rgba(255, 87, 34, 0.45)'
  ];

  let datasets = [];
  let hoveredIndex = null;
  let scaleMode = 'full';
  let currentRange = { min: 0, max: clampInt(coinInput.value, 1, 5000, 100) };

  function formatProbability(prob) {
    return `${(prob * 100).toFixed(2)}%`;
  }

  function formatHeadsTails(probValue) {
    const heads = probValue;
    const tails = 100 - probValue;
    return `орёл/решка: <span class="value-strong">${heads}%</span> / <span class="value-strong">${tails}%</span>`;
  }

  function createProbabilityRow(defaultValue = 50) {
    const row = document.createElement('div');
    row.className = 'probability-row';
    const safeDefault = clampInt(defaultValue, 0, 100, 50);

    const colorDot = document.createElement('div');
    colorDot.className = 'color-dot';
    const color = colors[(probabilityList.children.length) % colors.length];
    colorDot.style.background = color;

    const label = document.createElement('label');
    label.className = 'mut-label';
    //label.textContent = 'Вероятность выпадения орла, %:';

    const input = document.createElement('input');
    input.type = 'range';
    input.min = '0';
    input.max = '100';
    input.step = '1';
    input.value = safeDefault;
    input.addEventListener('input', () => {
      const v = clampInt(input.value, 0, 100, safeDefault);
      input.value = v;
      probText.innerHTML = `${formatHeadsTails(v)}`;
      handleCreate();
    });

    label.appendChild(input);

    const probText = document.createElement('span');
    probText.className = 'prob-display';
    probText.style.fontSize = '12px';
    probText.style.color = '#444';
    probText.innerHTML = `${formatHeadsTails(safeDefault)}`;

    const meanText = document.createElement('span');
    meanText.className = 'mean-display';
    meanText.style.fontSize = '12px';
    meanText.style.color = '#444';

    const info = document.createElement('span');
    info.className = 'prob-info';
    info.style.fontSize = '12px';
    info.style.color = '#555';

    row.appendChild(colorDot);
    row.appendChild(label);
    row.appendChild(probText);
    row.appendChild(meanText);
    row.appendChild(info);
    probabilityList.appendChild(row);
  }

  function refreshColorDots() {
    Array.from(probabilityList.children).forEach((row, idx) => {
      const dot = row.querySelector('.color-dot');
      dot.style.background = colors[idx % colors.length];
    });
  }

  function updateRemoveButtonState() {
    removeProbBtn.disabled = probabilityList.children.length <= 1;
  }

  function addDefaultRow() {
    createProbabilityRow(50);
    updateRemoveButtonState();
  }

  function binomialProbs(coinCount, p) {
    const probs = new Array(coinCount + 1).fill(0);

    if (coinCount === 0) {
      probs[0] = 1;
      return probs;
    }

    if (p <= 0) {
      probs[0] = 1;
      return probs;
    }

    if (p >= 1) {
      probs[coinCount] = 1;
      return probs;
    }

    const logFact = new Array(coinCount + 1).fill(0);
    for (let i = 1; i <= coinCount; i++) {
      logFact[i] = logFact[i - 1] + Math.log(i);
    }

    const logP = Math.log(p);
    const logQ = Math.log(1 - p);
    let maxLog = -Infinity;
    const logProbs = new Array(coinCount + 1);

    for (let k = 0; k <= coinCount; k++) {
      const logProb = logFact[coinCount] - logFact[k] - logFact[coinCount - k] + k * logP + (coinCount - k) * logQ;
      logProbs[k] = logProb;
      if (logProb > maxLog) maxLog = logProb;
    }

    let sum = 0;
    for (let k = 0; k <= coinCount; k++) {
      const value = Math.exp(logProbs[k] - maxLog);
      probs[k] = value;
      sum += value;
    }

    for (let k = 0; k <= coinCount; k++) {
      probs[k] = probs[k] / sum;
    }

    return probs;
  }

  function calculateRange(simulatedDatasets, fallbackCoinCount) {
    const defaultRange = { min: 0, max: fallbackCoinCount };

    if (scaleMode !== 'auto' || !simulatedDatasets || simulatedDatasets.length === 0) {
      return defaultRange;
    }

    let minObserved = Infinity;
    let maxObserved = -Infinity;

    simulatedDatasets.forEach(({ probs, p, coinCount }) => {
      const n = coinCount ?? fallbackCoinCount;
      if (Number.isFinite(p) && Number.isFinite(n)) {
        const mean = n * p;
        const variance = n * p * (1 - p);
        const sigma = Math.sqrt(variance);
        const spread = Math.max(1, sigma * 5);
        const localMin = Math.max(0, Math.floor(mean - spread));
        const localMax = Math.min(n, Math.ceil(mean + spread));
        minObserved = Math.min(minObserved, localMin);
        maxObserved = Math.max(maxObserved, localMax);
        return;
      }

      if (!probs) return;
      for (let i = 0; i < probs.length; i++) {
        if (probs[i] > 0) {
          minObserved = Math.min(minObserved, i);
          maxObserved = Math.max(maxObserved, i);
        }
      }
    });

    if (!Number.isFinite(minObserved) || !Number.isFinite(maxObserved)) return defaultRange;
    if (minObserved === maxObserved) {
      const min = Math.max(0, minObserved - 1);
      const max = Math.min(fallbackCoinCount, maxObserved + 1);
      return { min, max };
    }

    return { min: minObserved, max: maxObserved };
  }

  function draw(simulatedDatasets) {
    const inputCoinCount = clampInt(coinInput.value, 1, 5000, 100);
    const coinCountValue = simulatedDatasets?.[0]?.probs?.length
      ? simulatedDatasets[0].probs.length - 1
      : inputCoinCount;
    coinInput.value = inputCoinCount;

    const { min: xMin, max: xMax } = calculateRange(simulatedDatasets, coinCountValue);
    currentRange = { min: xMin, max: xMax };
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;
    const dpr = window.devicePixelRatio || 1;
    const displayWidth = canvas.clientWidth || canvas.parentElement.clientWidth || 600;
    const targetHeight = Math.max(280, Math.min(window.innerHeight * 0.6, 520));
    canvas.style.height = `${targetHeight}px`;
    canvas.width = Math.floor(displayWidth * dpr);
    canvas.height = Math.floor(targetHeight * dpr);

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    const marginLeft = 64;
    const marginRight = 16;
    const marginBottom = 40;
    const marginTop = 18;
    const innerWidth = width - marginLeft - marginRight;
    const innerHeight = height - marginTop - marginBottom;

    ctx.fillStyle = '#f8f9fc';
    ctx.fillRect(marginLeft, marginTop, innerWidth, innerHeight);

    if (!simulatedDatasets || simulatedDatasets.length === 0) {
      drawAxesOnly(ctx, { xMin, xMax, marginLeft, marginTop, innerWidth, innerHeight, width, height });
      updateHoverInfo(null);
      return;
    }

    let globalMaxProb = 0;
    simulatedDatasets.forEach(({ probs }) => {
      const maxProb = Math.max(...probs, 0);
      globalMaxProb = Math.max(globalMaxProb, maxProb);
    });

    const { ticks: yTicks, maxValue: yMax } = generateYTicks(globalMaxProb);
    const scaleY = yMax > 0 ? innerHeight / yMax : 0;

    simulatedDatasets.forEach(({ probs, color }) => {
      ctx.fillStyle = color;
      const barWidth = innerWidth / xRange;
      for (let i = 0; i < probs.length; i++) {
        const prob = probs[i];
        if (prob === 0) continue;
        const xLeft = marginLeft + ((i - 0.5 - xMinEdge) / xRange) * innerWidth;
        const h = prob * scaleY;
        if (h < 1) continue;
        const y = marginTop + innerHeight - h;
        if (xLeft + barWidth < marginLeft || xLeft > width - marginRight) continue;
        const drawWidth = Math.max(1, barWidth * 0.9);
        const x = xLeft + (barWidth - drawWidth) / 2;
        ctx.fillRect(x, y, drawWidth, h);
      }
    });

    drawAxesOnly(ctx, { xMin, xMax, marginLeft, marginTop, innerWidth, innerHeight, width, height, yTicks, yMax });
    updateHoverInfo();
  }

  function collectProbabilities(coinCountValue) {
    const values = [];
    Array.from(probabilityList.children).forEach((row, idx) => {
      const input = row.querySelector('input[type="range"]');
      const value = clampInt(input?.value, 0, 100, 50);
      input.value = value;
      const probText = row.querySelector('.prob-display');
      if (probText) probText.innerHTML = `${formatHeadsTails(value)}`;
      const meanText = row.querySelector('.mean-display');
      if (meanText) {
        meanText.innerHTML = `| Среднее: <span class="value-strong">${(coinCountValue * (value / 100)).toFixed(2)}</span>`;
      }
      const color = colors[idx % colors.length];
      values.push({ p: value / 100, label: `${value}%`, color });
    });
    return values;
  }

  function updateHoverInfo(index = hoveredIndex) {
    if (!datasets.length) {
      Array.from(probabilityList.children).forEach((row) => {
        const info = row.querySelector('.prob-info');
        if (info) info.textContent = '';
      });
      return;
    }

    const datasetCoinCount = datasets[0]?.probs.length ? datasets[0].probs.length - 1 : clampInt(coinInput.value, 1, 5000, 100);
    const displayIndex = index === null ? Math.floor(datasetCoinCount / 2) : Math.max(0, Math.min(datasetCoinCount, index));

    Array.from(probabilityList.children).forEach((row, idx) => {
      const info = row.querySelector('.prob-info');
      const dataset = datasets[idx];
      if (!info || !dataset) {
        if (info) info.textContent = '';
        return;
      }
      const currentCoinCount = dataset.probs.length - 1;
      const clampedIndex = Math.min(displayIndex, currentCoinCount);
      const prob = dataset.probs[clampedIndex] || 0;
      info.innerHTML = `| Значение: <span class="value-strong">${clampedIndex}</span>/<span class="value-strong">${currentCoinCount - clampedIndex}</span> | Вероятность: <span class="value-strong">${formatProbability(prob)}</span>`;
    });
  }

  function handleMouseMove(event) {
    if (!datasets.length) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const marginLeft = 64;
    const marginRight = 16;
    const innerWidth = rect.width - marginLeft - marginRight;
    const coinCountValue = datasets[0]?.probs.length ? datasets[0].probs.length - 1 : clampInt(coinInput.value, 1, 5000, 100);
    const xMin = currentRange.min;
    const xMax = currentRange.max;
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;

    if (x < marginLeft || x > rect.width - marginRight) {
      hoveredIndex = null;
      updateHoverInfo();
      return;
    }

    const value = xMinEdge + ((x - marginLeft) / innerWidth) * xRange;
    let idx = Math.round(value);
    idx = Math.max(0, Math.min(coinCountValue, idx));
    hoveredIndex = idx;
    updateHoverInfo(hoveredIndex);
  }

  function handleMouseLeave() {
    hoveredIndex = null;
    updateHoverInfo();
  }

  function handleCreate() {
    const coinCountValue = clampInt(coinInput.value, 1, 5000, 100);
    coinInput.value = coinCountValue;

    const probabilities = collectProbabilities(coinCountValue);
    if (probabilities.length === 0) {
      addDefaultRow();
      return;
    }

    const simulatedDatasets = probabilities.map(({ p, label, color }) => {
      const probs = binomialProbs(coinCountValue, p);
      return { probs, label, color, p, coinCount: coinCountValue };
    });

    datasets = simulatedDatasets;
    draw(datasets);
    updateHoverInfo();
  }

  addProbBtn.addEventListener('click', () => {
    createProbabilityRow(50);
    refreshColorDots();
    updateRemoveButtonState();
    handleCreate();
  });

  removeProbBtn.addEventListener('click', () => {
    const rows = probabilityList.children;
    if (rows.length <= 1) return;
    probabilityList.removeChild(rows[rows.length - 1]);
    refreshColorDots();
    updateRemoveButtonState();
    handleCreate();
  });

  scaleModeSelect.addEventListener('change', (e) => {
    scaleMode = e.target.value;
    draw(datasets);
  });

  coinInput.addEventListener('input', handleCreate);
  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mouseleave', handleMouseLeave);
  window.addEventListener('resize', () => draw(datasets));

  addDefaultRow();
  handleCreate();
  updateRemoveButtonState();
</script>
</body>
</html>
