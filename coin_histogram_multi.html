<!--
Interactive science demo.
Part of the "science-demos" project.

GitHub: https://github.com/yupic/science-demos
YouTube: https://www.youtube.com/@autism-ru
Telegram: https://t.me/autism_science
License: MIT
-->
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Распределение числа орлов (несколько вероятностей)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f7f7f8;
      --fg: #222;
      --accent: #2c7be5;
      --muted: #666;
      --card: #fff;
      --border: #d5d7db;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--fg);
    }
    .container {
      margin: 0 auto;
      padding: 18px 18px 0;
      width: 100%;
      max-width: 1200px;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 22px;
      font-weight: 650;
    }
    p.desc {
      margin: 0 0 14px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.5;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 10px;
      align-items: center;
      padding: 10px 12px;
      background: #eef0f6;
      border: 1px solid #e2e4ea;
      border-radius: 10px;
    }
    button {
      border: 1px solid var(--border);
      background: var(--card);
      border-radius: 6px;
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    button:hover { background: #f0f4ff; }
    button:active {
      transform: translateY(1px);
      box-shadow: 0 0 0 rgba(0,0,0,0.05);
    }
    select, input[type="number"] {
      padding: 6px 8px;
      font-size: 14px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--card);
    }
    .mut-label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
    }
    .probability-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 6px;
      margin-bottom: 10px;
    }
    .prob-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    .probability-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 10px 12px;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
    }
    .probability-row span { white-space: nowrap; }
    .probability-row input[type="range"] {
      width: 240px;
    }
    .probability-row .color-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid var(--border);
      flex-shrink: 0;
    }
    .canvas-frame {
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      overflow: hidden;
      position: relative;
      width: 100%;
      box-shadow: 0 4px 10px rgba(0,0,0,0.06);
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      background: #fff;
    }
    .note {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
      line-height: 1.5;
    }

    .value-strong {
      font-weight: 700;
    }

    .icon-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 20px;
      border: 1px solid #d6d9e0;
      background: #fff;
      color: #444;
      font-size: 13px;
      font-weight: 600;
    }

    .icon-circle {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      font-size: 14px;
      font-weight: 700;
      color: #fff;
    }

    .icon-blue { background: #1f74e9; }
    .icon-red { background: #e53935; }
    @media (max-width: 600px) {
      h1 { font-size: 20px; }
      .probability-row input { width: 100px; }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Распределение числа выпавших орлов</h1>
  <p class="desc">Сравните гистограммы для разной вероятности выпадения орла. Укажите число монет и несколько вариантов вероятностей — распределения обновляются сразу при изменениях.</p>
  <div class="controls">
    <label class="mut-label">Монет:
      <input type="number" id="coinCount" min="1" max="5000" value="5000" />
    </label>
    <label class="mut-label">Масштаб:
      <select id="scaleMode">
        <option value="auto" selected>Авто</option>
        <option value="full">Полный</option>
      </select>
    </label>
    <div class="prob-actions">
      <button id="addProbBtn" class="icon-btn">
        <span class="icon-circle icon-blue">+</span>
        Добавить/удалить гистограмму
      </button>
      <button id="removeProbBtn" class="icon-btn" disabled>
        <span class="icon-circle icon-red">×</span>
      </button>
    </div>
  </div>
  <div class="probability-section">
    <div class="probability-list" id="probabilityList"></div>
  </div>
  <div class="canvas-frame">
    <canvas id="histCanvas"></canvas>
  </div>
  <div class="note">Цвета гистограмм полупрозрачные, поэтому распределения могут накладываться друг на друга.</div>
</div>
<div style="margin: 10px 0; font-size:12px; color:#999; text-align:center;">
  © autism_science • MIT License •
  <a href="https://github.com/yupic/science-demos" target="_blank" rel="noopener" style="color:#999;">GitHub</a> •
  <a href="https://www.youtube.com/@autism-ru" target="_blank" rel="noopener" style="color:#999;">YouTube</a> •
  <a href="https://t.me/autism_science" target="_blank" rel="noopener" style="color:#999;">Telegram</a>
</div>
<script>
  const canvas = document.getElementById('histCanvas');
  const ctx = canvas.getContext('2d');
  const coinInput = document.getElementById('coinCount');
  const addProbBtn = document.getElementById('addProbBtn');
  const removeProbBtn = document.getElementById('removeProbBtn');
  const probabilityList = document.getElementById('probabilityList');
  const scaleModeSelect = document.getElementById('scaleMode');

  const colors = [
    'rgba(44, 123, 229, 0.45)',
    'rgba(227, 52, 47, 0.45)',
    'rgba(52, 168, 83, 0.45)',
    'rgba(255, 193, 7, 0.45)',
    'rgba(156, 39, 176, 0.45)',
    'rgba(0, 188, 212, 0.45)',
    'rgba(255, 87, 34, 0.45)'
  ];

  let datasets = [];
  let hoveredIndex = null;
  let scaleMode = 'auto';
  let currentRange = { min: 0, max: clampInt(coinInput.value, 1, 5000, 5000) };

  function clampInt(value, min, max, fallback) {
    const n = parseInt(value, 10);
    if (!Number.isFinite(n)) return fallback;
    return Math.min(Math.max(n, min), max);
  }

  function formatProbability(prob) {
    return `${(prob * 100).toFixed(2)}%`;
  }

  function formatHeadsTails(probValue) {
    const heads = probValue;
    const tails = 100 - probValue;
    return `орёл/решка: <span class="value-strong">${heads}%</span> / <span class="value-strong">${tails}%</span>`;
  }

  function createProbabilityRow(defaultValue = 50) {
    const row = document.createElement('div');
    row.className = 'probability-row';
    const safeDefault = clampInt(defaultValue, 0, 100, 50);

    const colorDot = document.createElement('div');
    colorDot.className = 'color-dot';
    const color = colors[(probabilityList.children.length) % colors.length];
    colorDot.style.background = color;

    const label = document.createElement('label');
    label.className = 'mut-label';
    label.textContent = 'Вероятность выпадения орла, %:';

    const input = document.createElement('input');
    input.type = 'range';
    input.min = '0';
    input.max = '100';
    input.step = '1';
    input.value = safeDefault;
    input.addEventListener('input', () => {
      const v = clampInt(input.value, 0, 100, safeDefault);
      input.value = v;
      probText.innerHTML = `${formatHeadsTails(v)} | Вероятность: <span class="value-strong">${v}%</span>`;
      handleCreate();
    });

    label.appendChild(input);

    const probText = document.createElement('span');
    probText.className = 'prob-display';
    probText.style.fontSize = '12px';
    probText.style.color = '#444';
    probText.innerHTML = `${formatHeadsTails(safeDefault)} | Вероятность: <span class="value-strong">${safeDefault}%</span>`;

    const meanText = document.createElement('span');
    meanText.className = 'mean-display';
    meanText.style.fontSize = '12px';
    meanText.style.color = '#444';

    const info = document.createElement('span');
    info.className = 'prob-info';
    info.style.fontSize = '12px';
    info.style.color = '#555';

    row.appendChild(colorDot);
    row.appendChild(label);
    row.appendChild(probText);
    row.appendChild(meanText);
    row.appendChild(info);
    probabilityList.appendChild(row);
  }

  function refreshColorDots() {
    Array.from(probabilityList.children).forEach((row, idx) => {
      const dot = row.querySelector('.color-dot');
      dot.style.background = colors[idx % colors.length];
    });
  }

  function updateRemoveButtonState() {
    removeProbBtn.disabled = probabilityList.children.length <= 1;
  }

  function addDefaultRow() {
    createProbabilityRow(50);
    updateRemoveButtonState();
  }

  function binomialProbs(coinCount, p) {
    const probs = new Array(coinCount + 1).fill(0);

    if (coinCount === 0) {
      probs[0] = 1;
      return probs;
    }

    if (p <= 0) {
      probs[0] = 1;
      return probs;
    }

    if (p >= 1) {
      probs[coinCount] = 1;
      return probs;
    }

    const logFact = new Array(coinCount + 1).fill(0);
    for (let i = 1; i <= coinCount; i++) {
      logFact[i] = logFact[i - 1] + Math.log(i);
    }

    const logP = Math.log(p);
    const logQ = Math.log(1 - p);
    let maxLog = -Infinity;
    const logProbs = new Array(coinCount + 1);

    for (let k = 0; k <= coinCount; k++) {
      const logProb = logFact[coinCount] - logFact[k] - logFact[coinCount - k] + k * logP + (coinCount - k) * logQ;
      logProbs[k] = logProb;
      if (logProb > maxLog) maxLog = logProb;
    }

    let sum = 0;
    for (let k = 0; k <= coinCount; k++) {
      const value = Math.exp(logProbs[k] - maxLog);
      probs[k] = value;
      sum += value;
    }

    for (let k = 0; k <= coinCount; k++) {
      probs[k] = probs[k] / sum;
    }

    return probs;
  }

  function generateXTicks(domain, widthPx, minLabelGapPx = 34) {
    const width = Math.max(0, widthPx);
    const maxLabels = Math.floor(width / minLabelGapPx);
    if (maxLabels < 2) return [];

    const range = Math.abs(domain.max - domain.min);
    if (range === 0) return [domain.min];

    const targetLabels = Math.min(maxLabels, 31);
    let rawStep = range / (targetLabels - 1);
    const m = Math.pow(10, Math.floor(Math.log10(rawStep)));
    const x = rawStep / m;
    let niceBase;
    if (x <= 1) niceBase = 1;
    else if (x <= 2) niceBase = 2;
    else if (x <= 5) niceBase = 5;
    else niceBase = 10;
    let step = Math.max(1, niceBase * m);

    const buildTicks = () => {
      const ticks = [];
      const start = Math.ceil(domain.min / step) * step;
      for (let v = start; v <= domain.max + step * 0.001; v += step) {
        const rounded = Number((Math.round(v / step) * step).toFixed(10));
        ticks.push(rounded);
      }
      return ticks;
    };

    let ticks = buildTicks();
    if (ticks.length > maxLabels) {
      step *= 2;
      ticks = buildTicks();
    }
    return ticks;
  }

  function generateYTicks(maxProb) {
    const maxValue = maxProb > 0 ? maxProb : 1;
    const ticks = Array.from({ length: 5 }, (_, i) => (maxValue * i) / 4);
    return { ticks, maxValue };
  }

  function calculateRange(simulatedDatasets, fallbackCoinCount) {
    const defaultRange = { min: 0, max: fallbackCoinCount };

    if (scaleMode !== 'auto' || !simulatedDatasets || simulatedDatasets.length === 0) {
      return defaultRange;
    }

    let minObserved = Infinity;
    let maxObserved = -Infinity;

    simulatedDatasets.forEach(({ probs, p, coinCount }) => {
      const n = coinCount ?? fallbackCoinCount;
      if (Number.isFinite(p) && Number.isFinite(n)) {
        const mean = n * p;
        const variance = n * p * (1 - p);
        const sigma = Math.sqrt(variance);
        const spread = Math.max(1, sigma * 5);
        const localMin = Math.max(0, Math.floor(mean - spread));
        const localMax = Math.min(n, Math.ceil(mean + spread));
        minObserved = Math.min(minObserved, localMin);
        maxObserved = Math.max(maxObserved, localMax);
        return;
      }

      if (!probs) return;
      for (let i = 0; i < probs.length; i++) {
        if (probs[i] > 0) {
          minObserved = Math.min(minObserved, i);
          maxObserved = Math.max(maxObserved, i);
        }
      }
    });

    if (!Number.isFinite(minObserved) || !Number.isFinite(maxObserved)) return defaultRange;
    if (minObserved === maxObserved) {
      const min = Math.max(0, minObserved - 1);
      const max = Math.min(fallbackCoinCount, maxObserved + 1);
      return { min, max };
    }

    return { min: minObserved, max: maxObserved };
  }

  function draw(simulatedDatasets) {
    const inputCoinCount = clampInt(coinInput.value, 1, 5000, 5000);
    const coinCountValue = simulatedDatasets?.[0]?.probs?.length
      ? simulatedDatasets[0].probs.length - 1
      : inputCoinCount;
    coinInput.value = inputCoinCount;

    const { min: xMin, max: xMax } = calculateRange(simulatedDatasets, coinCountValue);
    currentRange = { min: xMin, max: xMax };
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;
    const dpr = window.devicePixelRatio || 1;
    const displayWidth = canvas.clientWidth || canvas.parentElement.clientWidth || 600;
    const targetHeight = Math.max(280, Math.min(window.innerHeight * 0.6, 520));
    canvas.style.height = `${targetHeight}px`;
    canvas.width = Math.floor(displayWidth * dpr);
    canvas.height = Math.floor(targetHeight * dpr);

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    const marginLeft = 64;
    const marginRight = 16;
    const marginBottom = 40;
    const marginTop = 18;
    const innerWidth = width - marginLeft - marginRight;
    const innerHeight = height - marginTop - marginBottom;

    ctx.fillStyle = '#f8f9fc';
    ctx.fillRect(marginLeft, marginTop, innerWidth, innerHeight);

    if (!simulatedDatasets || simulatedDatasets.length === 0) {
      drawAxesOnly({ xMin, xMax, marginLeft, marginTop, innerWidth, innerHeight, width, height });
      updateHoverInfo(null);
      return;
    }

    let globalMaxProb = 0;
    simulatedDatasets.forEach(({ probs }) => {
      const maxProb = Math.max(...probs, 0);
      globalMaxProb = Math.max(globalMaxProb, maxProb);
    });

    const { ticks: yTicks, maxValue: yMax } = generateYTicks(globalMaxProb);
    const scaleY = yMax > 0 ? innerHeight / yMax : 0;

    simulatedDatasets.forEach(({ probs, color }) => {
      ctx.fillStyle = color;
      const barWidth = innerWidth / xRange;
      for (let i = 0; i < probs.length; i++) {
        const prob = probs[i];
        if (prob === 0) continue;
        const xLeft = marginLeft + ((i - 0.5 - xMinEdge) / xRange) * innerWidth;
        const h = prob * scaleY;
        if (h < 1) continue;
        const y = marginTop + innerHeight - h;
        if (xLeft + barWidth < marginLeft || xLeft > width - marginRight) continue;
        const drawWidth = Math.max(1, barWidth * 0.9);
        const x = xLeft + (barWidth - drawWidth) / 2;
        ctx.fillRect(x, y, drawWidth, h);
      }
    });

    drawAxesOnly({ xMin, xMax, marginLeft, marginTop, innerWidth, innerHeight, width, height, yTicks, yMax });
    updateHoverInfo();
  }

  function drawAxesOnly({ xMin, xMax, marginLeft, marginTop, innerWidth, innerHeight, width, height, yTicks = [0, 0.25, 0.5, 0.75, 1], yMax = 1 }) {
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;
    const marginRight = 16;
    const marginBottom = 40;

    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(marginLeft, marginTop + innerHeight);
    ctx.lineTo(width - marginRight, marginTop + innerHeight);
    ctx.stroke();

    ctx.fillStyle = '#444';
    ctx.font = '12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const labelValues = generateXTicks({ min: xMin, max: xMax }, innerWidth);
    const stepForFormat = labelValues.length >= 2 ? Math.abs(labelValues[1] - labelValues[0]) : 1;
    const decimals = stepForFormat >= 1 ? 0 : Math.max(0, Math.min(6, Math.ceil(-Math.log10(stepForFormat))));
    const formatTick = (value) => {
      if (decimals === 0) return Math.round(value).toString();
      return Number(value.toFixed(decimals)).toString();
    };

    for (const value of labelValues) {
      const x = marginLeft + ((value - xMinEdge) / xRange) * innerWidth;
      const label = formatTick(value);
      ctx.fillText(label, x, marginTop + innerHeight + 6);
    }

    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (const prob of yTicks) {
      const y = marginTop + innerHeight - (prob / yMax) * innerHeight;
      ctx.fillText(`${(prob * 100).toFixed(2)}%`, marginLeft - 8, y);
    }

    ctx.save();
    const yLabelX = Math.max(4, marginLeft - 74);
    ctx.translate(yLabelX, marginTop + innerHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('Вероятность', 0, 0);
    ctx.restore();

    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  function collectProbabilities(coinCountValue) {
    const values = [];
    Array.from(probabilityList.children).forEach((row, idx) => {
      const input = row.querySelector('input[type="range"]');
      const value = clampInt(input?.value, 0, 100, 50);
      input.value = value;
      const probText = row.querySelector('.prob-display');
      if (probText) probText.innerHTML = `${formatHeadsTails(value)} | Вероятность: <span class="value-strong">${value}%</span>`;
      const meanText = row.querySelector('.mean-display');
      if (meanText) {
        meanText.innerHTML = `| Среднее: <span class="value-strong">${(coinCountValue * (value / 100)).toFixed(2)}</span>`;
      }
      const color = colors[idx % colors.length];
      values.push({ p: value / 100, label: `${value}%`, color });
    });
    return values;
  }

  function updateHoverInfo(index = hoveredIndex) {
    if (!datasets.length) {
      Array.from(probabilityList.children).forEach((row) => {
        const info = row.querySelector('.prob-info');
        if (info) info.textContent = '';
      });
      return;
    }

    const datasetCoinCount = datasets[0]?.probs.length ? datasets[0].probs.length - 1 : clampInt(coinInput.value, 1, 5000, 5000);
    const displayIndex = index === null ? Math.floor(datasetCoinCount / 2) : Math.max(0, Math.min(datasetCoinCount, index));

    Array.from(probabilityList.children).forEach((row, idx) => {
      const info = row.querySelector('.prob-info');
      const dataset = datasets[idx];
      if (!info || !dataset) {
        if (info) info.textContent = '';
        return;
      }
      const currentCoinCount = dataset.probs.length - 1;
      const clampedIndex = Math.min(displayIndex, currentCoinCount);
      const prob = dataset.probs[clampedIndex] || 0;
      info.innerHTML = `| Значение: <span class="value-strong">${clampedIndex}</span>/<span class="value-strong">${currentCoinCount - clampedIndex}</span> | Вероятность: <span class="value-strong">${formatProbability(prob)}</span>`;
    });
  }

  function handleMouseMove(event) {
    if (!datasets.length) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const marginLeft = 64;
    const marginRight = 16;
    const innerWidth = rect.width - marginLeft - marginRight;
    const coinCountValue = datasets[0]?.probs.length ? datasets[0].probs.length - 1 : clampInt(coinInput.value, 1, 5000, 5000);
    const xMin = currentRange.min;
    const xMax = currentRange.max;
    const xMinEdge = xMin - 0.5;
    const xMaxEdge = xMax + 0.5;
    const xRange = xMaxEdge - xMinEdge || 1;

    if (x < marginLeft || x > rect.width - marginRight) {
      hoveredIndex = null;
      updateHoverInfo();
      return;
    }

    const value = xMinEdge + ((x - marginLeft) / innerWidth) * xRange;
    let idx = Math.round(value);
    idx = Math.max(0, Math.min(coinCountValue, idx));
    hoveredIndex = idx;
    updateHoverInfo(hoveredIndex);
  }

  function handleMouseLeave() {
    hoveredIndex = null;
    updateHoverInfo();
  }

  function handleCreate() {
    const coinCountValue = clampInt(coinInput.value, 1, 5000, 5000);
    coinInput.value = coinCountValue;

    const probabilities = collectProbabilities(coinCountValue);
    if (probabilities.length === 0) {
      addDefaultRow();
      return;
    }

    const simulatedDatasets = probabilities.map(({ p, label, color }) => {
      const probs = binomialProbs(coinCountValue, p);
      return { probs, label, color, p, coinCount: coinCountValue };
    });

    datasets = simulatedDatasets;
    draw(datasets);
    updateHoverInfo();
  }

  addProbBtn.addEventListener('click', () => {
    createProbabilityRow(50);
    refreshColorDots();
    updateRemoveButtonState();
    handleCreate();
  });

  removeProbBtn.addEventListener('click', () => {
    const rows = probabilityList.children;
    if (rows.length <= 1) return;
    probabilityList.removeChild(rows[rows.length - 1]);
    refreshColorDots();
    updateRemoveButtonState();
    handleCreate();
  });

  scaleModeSelect.addEventListener('change', (e) => {
    scaleMode = e.target.value;
    draw(datasets);
  });

  coinInput.addEventListener('input', handleCreate);
  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mouseleave', handleMouseLeave);
  window.addEventListener('resize', () => draw(datasets));

  addDefaultRow();
  handleCreate();
  updateRemoveButtonState();
</script>
</body>
</html>
